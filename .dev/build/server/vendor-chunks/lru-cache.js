"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/lru-cache";
exports.ids = ["vendor-chunks/lru-cache"];
exports.modules = {

/***/ "(rsc)/./node_modules/lru-cache/dist/cjs/index.js":
/*!**************************************************!*\
  !*** ./node_modules/lru-cache/dist/cjs/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * @module LRUCache\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LRUCache = void 0;\nconst perf = typeof performance === \"object\" && performance && typeof performance.now === \"function\" ? performance : Date;\nconst warned = new Set();\n/* c8 ignore start */ const PROCESS = typeof process === \"object\" && !!process ? process : {};\n/* c8 ignore start */ const emitWarning = (msg, type, code, fn)=>{\n    typeof PROCESS.emitWarning === \"function\" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */ if (typeof AC === \"undefined\") {\n    //@ts-ignore\n    AS = class AbortSignal {\n        addEventListener(_, fn) {\n            this._onabort.push(fn);\n        }\n        constructor(){\n            this._onabort = [];\n            this.aborted = false;\n        }\n    };\n    //@ts-ignore\n    AC = class AbortController {\n        constructor(){\n            this.signal = new AS();\n            warnACPolyfill();\n        }\n        abort(reason) {\n            if (this.signal.aborted) return;\n            //@ts-ignore\n            this.signal.reason = reason;\n            //@ts-ignore\n            this.signal.aborted = true;\n            //@ts-ignore\n            for (const fn of this.signal._onabort){\n                fn(reason);\n            }\n            this.signal.onabort?.(reason);\n        }\n    };\n    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== \"1\";\n    const warnACPolyfill = ()=>{\n        if (!printACPolyfillWarning) return;\n        printACPolyfillWarning = false;\n        emitWarning(\"AbortController is not defined. If using lru-cache in \" + \"node 14, load an AbortController polyfill from the \" + \"`node-abort-controller` package. A minimal polyfill is \" + \"provided for use by LRUCache.fetch(), but it should not be \" + \"relied upon in other contexts (eg, passing it to other APIs that \" + \"use AbortController/AbortSignal might have undesirable effects). \" + \"You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.\", \"NO_ABORT_CONTROLLER\", \"ENOTSUP\", warnACPolyfill);\n    };\n}\n/* c8 ignore stop */ const shouldWarn = (code)=>!warned.has(code);\nconst TYPE = Symbol(\"type\");\nconst isPosInt = (n)=>n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */ // This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max)=>!isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;\n/* c8 ignore stop */ class ZeroArray extends Array {\n    constructor(size){\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    // private constructor\n    static #constructing = false;\n    static create(max) {\n        const HeapCls = getUintArray(max);\n        if (!HeapCls) return [];\n        Stack.#constructing = true;\n        const s = new Stack(max, HeapCls);\n        Stack.#constructing = false;\n        return s;\n    }\n    constructor(max, HeapCls){\n        /* c8 ignore start */ if (!Stack.#constructing) {\n            throw new TypeError(\"instantiate Stack using Stack.create(n)\");\n        }\n        /* c8 ignore stop */ this.heap = new HeapCls(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * All properties from the options object (with the exception of\n * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as\n * normal public members. (`max` and `maxBase` are read-only getters.)\n * Changing any of these will alter the defaults for subsequent method calls,\n * but is otherwise safe.\n */ class LRUCache {\n    // properties coming in from the options of these, only max and maxSize\n    // really *need* to be protected. The rest can be modified, as they just\n    // set defaults for various methods.\n    #max;\n    #maxSize;\n    #dispose;\n    #disposeAfter;\n    #fetchMethod;\n    // computed properties\n    #size;\n    #calculatedSize;\n    #keyMap;\n    #keyList;\n    #valList;\n    #next;\n    #prev;\n    #head;\n    #tail;\n    #free;\n    #disposed;\n    #sizes;\n    #starts;\n    #ttls;\n    #hasDispose;\n    #hasFetchMethod;\n    #hasDisposeAfter;\n    /**\n     * Do not call this method unless you need to inspect the\n     * inner workings of the cache.  If anything returned by this\n     * object is modified in any way, strange breakage may occur.\n     *\n     * These fields are private for a reason!\n     *\n     * @internal\n     */ static unsafeExposeInternals(c) {\n        return {\n            // properties\n            starts: c.#starts,\n            ttls: c.#ttls,\n            sizes: c.#sizes,\n            keyMap: c.#keyMap,\n            keyList: c.#keyList,\n            valList: c.#valList,\n            next: c.#next,\n            prev: c.#prev,\n            get head () {\n                return c.#head;\n            },\n            get tail () {\n                return c.#tail;\n            },\n            free: c.#free,\n            // methods\n            isBackgroundFetch: (p)=>c.#isBackgroundFetch(p),\n            backgroundFetch: (k, index, options, context)=>c.#backgroundFetch(k, index, options, context),\n            moveToTail: (index)=>c.#moveToTail(index),\n            indexes: (options)=>c.#indexes(options),\n            rindexes: (options)=>c.#rindexes(options),\n            isStale: (index)=>c.#isStale(index)\n        };\n    }\n    // Protected read-only members\n    /**\n     * {@link LRUCache.OptionsBase.max} (read-only)\n     */ get max() {\n        return this.#max;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.maxSize} (read-only)\n     */ get maxSize() {\n        return this.#maxSize;\n    }\n    /**\n     * The total computed size of items in the cache (read-only)\n     */ get calculatedSize() {\n        return this.#calculatedSize;\n    }\n    /**\n     * The number of items stored in the cache (read-only)\n     */ get size() {\n        return this.#size;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n     */ get fetchMethod() {\n        return this.#fetchMethod;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.dispose} (read-only)\n     */ get dispose() {\n        return this.#dispose;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n     */ get disposeAfter() {\n        return this.#disposeAfter;\n    }\n    constructor(options){\n        // conditionally set private methods related to TTL\n        this.#updateItemAge = ()=>{};\n        this.#statusTTL = ()=>{};\n        this.#setItemTTL = ()=>{};\n        /* c8 ignore stop */ this.#isStale = ()=>false;\n        this.#removeItemSize = (_i)=>{};\n        this.#addItemSize = (_i, _s, _st)=>{};\n        this.#requireSize = (_k, _v, size, sizeCalculation)=>{\n            if (size || sizeCalculation) {\n                throw new TypeError(\"cannot set size without setting maxSize or maxEntrySize on cache\");\n            }\n            return 0;\n        };\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError(\"max option must be a nonnegative integer\");\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error(\"invalid max value: \" + max);\n        }\n        this.#max = max;\n        this.#maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.#maxSize;\n        this.sizeCalculation = sizeCalculation;\n        if (this.sizeCalculation) {\n            if (!this.#maxSize && !this.maxEntrySize) {\n                throw new TypeError(\"cannot set sizeCalculation without setting maxSize or maxEntrySize\");\n            }\n            if (typeof this.sizeCalculation !== \"function\") {\n                throw new TypeError(\"sizeCalculation set to non-function\");\n            }\n        }\n        if (fetchMethod !== undefined && typeof fetchMethod !== \"function\") {\n            throw new TypeError(\"fetchMethod must be a function if specified\");\n        }\n        this.#fetchMethod = fetchMethod;\n        this.#hasFetchMethod = !!fetchMethod;\n        this.#keyMap = new Map();\n        this.#keyList = new Array(max).fill(undefined);\n        this.#valList = new Array(max).fill(undefined);\n        this.#next = new UintArray(max);\n        this.#prev = new UintArray(max);\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free = Stack.create(max);\n        this.#size = 0;\n        this.#calculatedSize = 0;\n        if (typeof dispose === \"function\") {\n            this.#dispose = dispose;\n        }\n        if (typeof disposeAfter === \"function\") {\n            this.#disposeAfter = disposeAfter;\n            this.#disposed = [];\n        } else {\n            this.#disposeAfter = undefined;\n            this.#disposed = undefined;\n        }\n        this.#hasDispose = !!this.#dispose;\n        this.#hasDisposeAfter = !!this.#disposeAfter;\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.#maxSize !== 0) {\n                if (!isPosInt(this.#maxSize)) {\n                    throw new TypeError(\"maxSize must be a positive integer if specified\");\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError(\"maxEntrySize must be a positive integer if specified\");\n            }\n            this.#initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError(\"ttl must be a positive integer if specified\");\n            }\n            this.#initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n            throw new TypeError(\"At least one of max, maxSize, or ttl is required\");\n        }\n        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n            const code = \"LRU_CACHE_UNBOUNDED\";\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = \"TTL caching without ttlAutopurge, max, or maxSize can \" + \"result in unbounded memory consumption.\";\n                emitWarning(msg, \"UnboundedCacheWarning\", code, LRUCache);\n            }\n        }\n    }\n    /**\n     * Return the remaining TTL time for a given entry key\n     */ getRemainingTTL(key) {\n        return this.#keyMap.has(key) ? Infinity : 0;\n    }\n    #initializeTTLTracking() {\n        const ttls = new ZeroArray(this.#max);\n        const starts = new ZeroArray(this.#max);\n        this.#ttls = ttls;\n        this.#starts = starts;\n        this.#setItemTTL = (index, ttl, start = perf.now())=>{\n            starts[index] = ttl !== 0 ? start : 0;\n            ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(()=>{\n                    if (this.#isStale(index)) {\n                        this.delete(this.#keyList[index]);\n                    }\n                }, ttl + 1);\n                // unref() not supported on all platforms\n                /* c8 ignore start */ if (t.unref) {\n                    t.unref();\n                }\n            /* c8 ignore stop */ }\n        };\n        this.#updateItemAge = (index)=>{\n            starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.#statusTTL = (status, index)=>{\n            if (ttls[index]) {\n                const ttl = ttls[index];\n                const start = starts[index];\n                status.ttl = ttl;\n                status.start = start;\n                status.now = cachedNow || getNow();\n                const age = status.now - start;\n                status.remainingTTL = ttl - age;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = ()=>{\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(()=>cachedNow = 0, this.ttlResolution);\n                // not available on all platforms\n                /* c8 ignore start */ if (t.unref) {\n                    t.unref();\n                }\n            /* c8 ignore stop */ }\n            return n;\n        };\n        this.getRemainingTTL = (key)=>{\n            const index = this.#keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            const ttl = ttls[index];\n            const start = starts[index];\n            if (ttl === 0 || start === 0) {\n                return Infinity;\n            }\n            const age = (cachedNow || getNow()) - start;\n            return ttl - age;\n        };\n        this.#isStale = (index)=>{\n            return ttls[index] !== 0 && starts[index] !== 0 && (cachedNow || getNow()) - starts[index] > ttls[index];\n        };\n    }\n    #updateItemAge;\n    #statusTTL;\n    #setItemTTL;\n    #isStale;\n    #initializeSizeTracking() {\n        const sizes = new ZeroArray(this.#max);\n        this.#calculatedSize = 0;\n        this.#sizes = sizes;\n        this.#removeItemSize = (index)=>{\n            this.#calculatedSize -= sizes[index];\n            sizes[index] = 0;\n        };\n        this.#requireSize = (k, v, size, sizeCalculation)=>{\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.#isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== \"function\") {\n                        throw new TypeError(\"sizeCalculation must be a function\");\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError(\"sizeCalculation return invalid (expect positive integer)\");\n                    }\n                } else {\n                    throw new TypeError(\"invalid size value (must be positive integer). \" + \"When maxSize or maxEntrySize is used, sizeCalculation \" + \"or size must be set.\");\n                }\n            }\n            return size;\n        };\n        this.#addItemSize = (index, size, status)=>{\n            sizes[index] = size;\n            if (this.#maxSize) {\n                const maxSize = this.#maxSize - sizes[index];\n                while(this.#calculatedSize > maxSize){\n                    this.#evict(true);\n                }\n            }\n            this.#calculatedSize += sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.#calculatedSize;\n            }\n        };\n    }\n    #removeItemSize;\n    #addItemSize;\n    #requireSize;\n    *#indexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for(let i = this.#tail; true;){\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#head) {\n                    break;\n                } else {\n                    i = this.#prev[i];\n                }\n            }\n        }\n    }\n    *#rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for(let i = this.#head; true;){\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#tail) {\n                    break;\n                } else {\n                    i = this.#next[i];\n                }\n            }\n        }\n    }\n    #isValidIndex(index) {\n        return index !== undefined && this.#keyMap.get(this.#keyList[index]) === index;\n    }\n    /**\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from most recently used to least recently used.\n     */ *entries() {\n        for (const i of this.#indexes()){\n            if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [\n                    this.#keyList[i],\n                    this.#valList[i]\n                ];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.entries}\n     *\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from least recently used to most recently used.\n     */ *rentries() {\n        for (const i of this.#rindexes()){\n            if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [\n                    this.#keyList[i],\n                    this.#valList[i]\n                ];\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the keys in the cache,\n     * in order from most recently used to least recently used.\n     */ *keys() {\n        for (const i of this.#indexes()){\n            const k = this.#keyList[i];\n            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.keys}\n     *\n     * Return a generator yielding the keys in the cache,\n     * in order from least recently used to most recently used.\n     */ *rkeys() {\n        for (const i of this.#rindexes()){\n            const k = this.#keyList[i];\n            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the values in the cache,\n     * in order from most recently used to least recently used.\n     */ *values() {\n        for (const i of this.#indexes()){\n            const v = this.#valList[i];\n            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.values}\n     *\n     * Return a generator yielding the values in the cache,\n     * in order from least recently used to most recently used.\n     */ *rvalues() {\n        for (const i of this.#rindexes()){\n            const v = this.#valList[i];\n            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Iterating over the cache itself yields the same results as\n     * {@link LRUCache.entries}\n     */ [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * Find a value for which the supplied fn method returns a truthy value,\n     * similar to Array.find().  fn is called as fn(value, key, cache).\n     */ find(fn, getOptions = {}) {\n        for (const i of this.#indexes()){\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined) continue;\n            if (fn(value, this.#keyList[i], this)) {\n                return this.get(this.#keyList[i], getOptions);\n            }\n        }\n    }\n    /**\n     * Call the supplied function on each item in the cache, in order from\n     * most recently used to least recently used.  fn is called as\n     * fn(value, key, cache).  Does not update age or recenty of use.\n     * Does not iterate over stale values.\n     */ forEach(fn, thisp = this) {\n        for (const i of this.#indexes()){\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined) continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * The same as {@link LRUCache.forEach} but items are iterated over in\n     * reverse order.  (ie, less recently used items are iterated over first.)\n     */ rforEach(fn, thisp = this) {\n        for (const i of this.#rindexes()){\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined) continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * Delete any stale entries. Returns true if anything was removed,\n     * false otherwise.\n     */ purgeStale() {\n        let deleted = false;\n        for (const i of this.#rindexes({\n            allowStale: true\n        })){\n            if (this.#isStale(i)) {\n                this.delete(this.#keyList[i]);\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n     * passed to cache.load()\n     */ dump() {\n        const arr = [];\n        for (const i of this.#indexes({\n            allowStale: true\n        })){\n            const key = this.#keyList[i];\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined || key === undefined) continue;\n            const entry = {\n                value\n            };\n            if (this.#ttls && this.#starts) {\n                entry.ttl = this.#ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = perf.now() - this.#starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.#sizes) {\n                entry.size = this.#sizes[i];\n            }\n            arr.unshift([\n                key,\n                entry\n            ]);\n        }\n        return arr;\n    }\n    /**\n     * Reset the cache and load in the items in entries in the order listed.\n     * Note that the shape of the resulting cache may be different if the\n     * same options are not used in both caches.\n     */ load(arr) {\n        this.clear();\n        for (const [key, entry] of arr){\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset, so that\n                // we get the intended remaining TTL, no matter how long it's\n                // been on ice.\n                //\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    /**\n     * Add a value to the cache.\n     *\n     * Note: if `undefined` is specified as a value, this is an alias for\n     * {@link LRUCache#delete}\n     */ set(k, v, setOptions = {}) {\n        if (v === undefined) {\n            this.delete(k);\n            return this;\n        }\n        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;\n        let { noUpdateTTL = this.noUpdateTTL } = setOptions;\n        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = \"miss\";\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case something is there already.\n            this.delete(k);\n            return this;\n        }\n        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;\n            this.#keyList[index] = k;\n            this.#valList[index] = v;\n            this.#keyMap.set(k, index);\n            this.#next[this.#tail] = index;\n            this.#prev[index] = this.#tail;\n            this.#tail = index;\n            this.#size++;\n            this.#addItemSize(index, size, status);\n            if (status) status.set = \"add\";\n            noUpdateTTL = false;\n        } else {\n            // update\n            this.#moveToTail(index);\n            const oldVal = this.#valList[index];\n            if (v !== oldVal) {\n                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error(\"replaced\"));\n                    const { __staleWhileFetching: s } = oldVal;\n                    if (s !== undefined && !noDisposeOnSet) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(s, k, \"set\");\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([\n                                s,\n                                k,\n                                \"set\"\n                            ]);\n                        }\n                    }\n                } else if (!noDisposeOnSet) {\n                    if (this.#hasDispose) {\n                        this.#dispose?.(oldVal, k, \"set\");\n                    }\n                    if (this.#hasDisposeAfter) {\n                        this.#disposed?.push([\n                            oldVal,\n                            k,\n                            \"set\"\n                        ]);\n                    }\n                }\n                this.#removeItemSize(index);\n                this.#addItemSize(index, size, status);\n                this.#valList[index] = v;\n                if (status) {\n                    status.set = \"replace\";\n                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;\n                    if (oldValue !== undefined) status.oldValue = oldValue;\n                }\n            } else if (status) {\n                status.set = \"update\";\n            }\n        }\n        if (ttl !== 0 && !this.#ttls) {\n            this.#initializeTTLTracking();\n        }\n        if (this.#ttls) {\n            if (!noUpdateTTL) {\n                this.#setItemTTL(index, ttl, start);\n            }\n            if (status) this.#statusTTL(status, index);\n        }\n        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while(task = dt?.shift()){\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return this;\n    }\n    /**\n     * Evict the least recently used item, returning its value or\n     * `undefined` if cache is empty.\n     */ pop() {\n        try {\n            while(this.#size){\n                const val = this.#valList[this.#head];\n                this.#evict(true);\n                if (this.#isBackgroundFetch(val)) {\n                    if (val.__staleWhileFetching) {\n                        return val.__staleWhileFetching;\n                    }\n                } else if (val !== undefined) {\n                    return val;\n                }\n            }\n        } finally{\n            if (this.#hasDisposeAfter && this.#disposed) {\n                const dt = this.#disposed;\n                let task;\n                while(task = dt?.shift()){\n                    this.#disposeAfter?.(...task);\n                }\n            }\n        }\n    }\n    #evict(free) {\n        const head = this.#head;\n        const k = this.#keyList[head];\n        const v = this.#valList[head];\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error(\"evicted\"));\n        } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n                this.#dispose?.(v, k, \"evict\");\n            }\n            if (this.#hasDisposeAfter) {\n                this.#disposed?.push([\n                    v,\n                    k,\n                    \"evict\"\n                ]);\n            }\n        }\n        this.#removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.#keyList[head] = undefined;\n            this.#valList[head] = undefined;\n            this.#free.push(head);\n        }\n        if (this.#size === 1) {\n            this.#head = this.#tail = 0;\n            this.#free.length = 0;\n        } else {\n            this.#head = this.#next[head];\n        }\n        this.#keyMap.delete(k);\n        this.#size--;\n        return head;\n    }\n    /**\n     * Check if a key is in the cache, without updating the recency of use.\n     * Will return false if the item is stale, even though it is technically\n     * in the cache.\n     *\n     * Will not update item age unless\n     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n     */ has(k, hasOptions = {}) {\n        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === undefined) {\n                return false;\n            }\n            if (!this.#isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.#updateItemAge(index);\n                }\n                if (status) {\n                    status.has = \"hit\";\n                    this.#statusTTL(status, index);\n                }\n                return true;\n            } else if (status) {\n                status.has = \"stale\";\n                this.#statusTTL(status, index);\n            }\n        } else if (status) {\n            status.has = \"miss\";\n        }\n        return false;\n    }\n    /**\n     * Like {@link LRUCache#get} but doesn't update recency or delete stale\n     * items.\n     *\n     * Returns `undefined` if the item is stale, unless\n     * {@link LRUCache.OptionsBase.allowStale} is set.\n     */ peek(k, peekOptions = {}) {\n        const { allowStale = this.allowStale } = peekOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined && (allowStale || !this.#isStale(index))) {\n            const v = this.#valList[index];\n            // either stale and allowed, or forcing a refresh of non-stale value\n            return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n        }\n    }\n    #backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.#valList[index];\n        if (this.#isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AC();\n        const { signal } = options;\n        // when/if our AC signals, then stop listening to theirs.\n        signal?.addEventListener(\"abort\", ()=>ac.abort(signal.reason), {\n            signal: ac.signal\n        });\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context\n        };\n        const cb = (v, updateCache = false)=>{\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort) options.status.fetchAbortIgnored = true;\n                } else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            const bf = p;\n            if (this.#valList[index] === p) {\n                if (v === undefined) {\n                    if (bf.__staleWhileFetching) {\n                        this.#valList[index] = bf.__staleWhileFetching;\n                    } else {\n                        this.delete(k);\n                    }\n                } else {\n                    if (options.status) options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er)=>{\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er)=>{\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            const bf = p;\n            if (this.#valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || bf.__staleWhileFetching === undefined;\n                if (del) {\n                    this.delete(k);\n                } else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.#valList[index] = bf.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && bf.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return bf.__staleWhileFetching;\n            } else if (bf.__returned === bf) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej)=>{\n            const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n            if (fmp && fmp instanceof Promise) {\n                fmp.then((v)=>res(v === undefined ? undefined : v), rej);\n            }\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener(\"abort\", ()=>{\n                if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {\n                    res(undefined);\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = (v)=>cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status) options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        const bf = Object.assign(p, {\n            __abortController: ac,\n            __staleWhileFetching: v,\n            __returned: undefined\n        });\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, bf, {\n                ...fetchOpts.options,\n                status: undefined\n            });\n            index = this.#keyMap.get(k);\n        } else {\n            this.#valList[index] = bf;\n        }\n        return bf;\n    }\n    #isBackgroundFetch(p) {\n        if (!this.#hasFetchMethod) return false;\n        const b = p;\n        return !!b && b instanceof Promise && b.hasOwnProperty(\"__staleWhileFetching\") && b.__abortController instanceof AC;\n    }\n    async fetch(k, fetchOptions = {}) {\n        const { // get options\n        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, // set options\n        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, // fetch exclusive options\n        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal } = fetchOptions;\n        if (!this.#hasFetchMethod) {\n            if (status) status.fetch = \"get\";\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal\n        };\n        let index = this.#keyMap.get(k);\n        if (index === undefined) {\n            if (status) status.fetch = \"miss\";\n            const p = this.#backgroundFetch(k, index, options, context);\n            return p.__returned = p;\n        } else {\n            // in cache, maybe already fetching\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = \"inflight\";\n                    if (stale) status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : v.__returned = v;\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.#isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status) status.fetch = \"hit\";\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                if (status) this.#statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.#backgroundFetch(k, index, options, context);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = isStale ? \"stale\" : \"refresh\";\n                if (staleVal && isStale) status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : p.__returned = p;\n        }\n    }\n    /**\n     * Return a value from the cache. Will update the recency of the cache\n     * entry found.\n     *\n     * If the key is not found, get() will return `undefined`.\n     */ get(k, getOptions = {}) {\n        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.#valList[index];\n            const fetching = this.#isBackgroundFetch(value);\n            if (status) this.#statusTTL(status, index);\n            if (this.#isStale(index)) {\n                if (status) status.get = \"stale\";\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.delete(k);\n                    }\n                    if (status && allowStale) status.returnedStale = true;\n                    return allowStale ? value : undefined;\n                } else {\n                    if (status && allowStale && value.__staleWhileFetching !== undefined) {\n                        status.returnedStale = true;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            } else {\n                if (status) status.get = \"hit\";\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                return value;\n            }\n        } else if (status) {\n            status.get = \"miss\";\n        }\n    }\n    #connect(p, n) {\n        this.#prev[n] = p;\n        this.#next[p] = n;\n    }\n    #moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.#tail) {\n            if (index === this.#head) {\n                this.#head = this.#next[index];\n            } else {\n                this.#connect(this.#prev[index], this.#next[index]);\n            }\n            this.#connect(this.#tail, index);\n            this.#tail = index;\n        }\n    }\n    /**\n     * Deletes a key out of the cache.\n     * Returns true if the key was deleted, false otherwise.\n     */ delete(k) {\n        let deleted = false;\n        if (this.#size !== 0) {\n            const index = this.#keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.#size === 1) {\n                    this.clear();\n                } else {\n                    this.#removeItemSize(index);\n                    const v = this.#valList[index];\n                    if (this.#isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error(\"deleted\"));\n                    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(v, k, \"delete\");\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([\n                                v,\n                                k,\n                                \"delete\"\n                            ]);\n                        }\n                    }\n                    this.#keyMap.delete(k);\n                    this.#keyList[index] = undefined;\n                    this.#valList[index] = undefined;\n                    if (index === this.#tail) {\n                        this.#tail = this.#prev[index];\n                    } else if (index === this.#head) {\n                        this.#head = this.#next[index];\n                    } else {\n                        this.#next[this.#prev[index]] = this.#next[index];\n                        this.#prev[this.#next[index]] = this.#prev[index];\n                    }\n                    this.#size--;\n                    this.#free.push(index);\n                }\n            }\n        }\n        if (this.#hasDisposeAfter && this.#disposed?.length) {\n            const dt = this.#disposed;\n            let task;\n            while(task = dt?.shift()){\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Clear the cache entirely, throwing away all values.\n     */ clear() {\n        for (const index of this.#rindexes({\n            allowStale: true\n        })){\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error(\"deleted\"));\n            } else {\n                const k = this.#keyList[index];\n                if (this.#hasDispose) {\n                    this.#dispose?.(v, k, \"delete\");\n                }\n                if (this.#hasDisposeAfter) {\n                    this.#disposed?.push([\n                        v,\n                        k,\n                        \"delete\"\n                    ]);\n                }\n            }\n        }\n        this.#keyMap.clear();\n        this.#valList.fill(undefined);\n        this.#keyList.fill(undefined);\n        if (this.#ttls && this.#starts) {\n            this.#ttls.fill(0);\n            this.#starts.fill(0);\n        }\n        if (this.#sizes) {\n            this.#sizes.fill(0);\n        }\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free.length = 0;\n        this.#calculatedSize = 0;\n        this.#size = 0;\n        if (this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while(task = dt?.shift()){\n                this.#disposeAfter?.(...task);\n            }\n        }\n    }\n}\nexports.LRUCache = LRUCache; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHJ1LWNhY2hlL2Rpc3QvY2pzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7O0NBRUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdCQUFnQixHQUFHLEtBQUs7QUFDeEIsTUFBTUcsT0FBTyxPQUFPQyxnQkFBZ0IsWUFDaENBLGVBQ0EsT0FBT0EsWUFBWUMsR0FBRyxLQUFLLGFBQ3pCRCxjQUNBRTtBQUNOLE1BQU1DLFNBQVMsSUFBSUM7QUFDbkIsbUJBQW1CLEdBQ25CLE1BQU1DLFVBQVcsT0FBT0MsWUFBWSxZQUFZLENBQUMsQ0FBQ0EsVUFBVUEsVUFBVSxDQUFDO0FBQ3ZFLG1CQUFtQixHQUNuQixNQUFNQyxjQUFjLENBQUNDLEtBQUtDLE1BQU1DLE1BQU1DO0lBQ2xDLE9BQU9OLFFBQVFFLFdBQVcsS0FBSyxhQUN6QkYsUUFBUUUsV0FBVyxDQUFDQyxLQUFLQyxNQUFNQyxNQUFNQyxNQUNyQ0MsUUFBUUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFSCxLQUFLLEVBQUUsRUFBRUQsS0FBSyxFQUFFLEVBQUVELElBQUksQ0FBQztBQUNuRDtBQUNBLElBQUlNLEtBQUtDLFdBQVdDLGVBQWU7QUFDbkMsSUFBSUMsS0FBS0YsV0FBV0csV0FBVztBQUMvQixtQkFBbUIsR0FDbkIsSUFBSSxPQUFPSixPQUFPLGFBQWE7SUFDM0IsWUFBWTtJQUNaRyxLQUFLLE1BQU1DO1FBS1BDLGlCQUFpQkMsQ0FBQyxFQUFFVCxFQUFFLEVBQUU7WUFDcEIsSUFBSSxDQUFDVSxRQUFRLENBQUNDLElBQUksQ0FBQ1g7UUFDdkI7O2lCQUxBVSxXQUFXLEVBQUU7aUJBRWJFLFVBQVU7O0lBSWQ7SUFDQSxZQUFZO0lBQ1pULEtBQUssTUFBTUU7UUFDUFEsYUFBYztpQkFHZEMsU0FBUyxJQUFJUjtZQUZUUztRQUNKO1FBRUFDLE1BQU1DLE1BQU0sRUFBRTtZQUNWLElBQUksSUFBSSxDQUFDSCxNQUFN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QUM1QjtRQUNKO0lBQ0o7QUFDSjtBQUNBdEwsZ0JBQWdCLEdBQUdFLFVBQ25CLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BmbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9kaXN0L2Nqcy9pbmRleC5qcz83OTM4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbW9kdWxlIExSVUNhY2hlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTFJVQ2FjaGUgPSB2b2lkIDA7XG5jb25zdCBwZXJmID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJlxuICAgIHBlcmZvcm1hbmNlICYmXG4gICAgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gcGVyZm9ybWFuY2VcbiAgICA6IERhdGU7XG5jb25zdCB3YXJuZWQgPSBuZXcgU2V0KCk7XG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IFBST0NFU1MgPSAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmICEhcHJvY2VzcyA/IHByb2Nlc3MgOiB7fSk7XG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IGVtaXRXYXJuaW5nID0gKG1zZywgdHlwZSwgY29kZSwgZm4pID0+IHtcbiAgICB0eXBlb2YgUFJPQ0VTUy5lbWl0V2FybmluZyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IFBST0NFU1MuZW1pdFdhcm5pbmcobXNnLCB0eXBlLCBjb2RlLCBmbilcbiAgICAgICAgOiBjb25zb2xlLmVycm9yKGBbJHtjb2RlfV0gJHt0eXBlfTogJHttc2d9YCk7XG59O1xubGV0IEFDID0gZ2xvYmFsVGhpcy5BYm9ydENvbnRyb2xsZXI7XG5sZXQgQVMgPSBnbG9iYWxUaGlzLkFib3J0U2lnbmFsO1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG5pZiAodHlwZW9mIEFDID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vQHRzLWlnbm9yZVxuICAgIEFTID0gY2xhc3MgQWJvcnRTaWduYWwge1xuICAgICAgICBvbmFib3J0O1xuICAgICAgICBfb25hYm9ydCA9IFtdO1xuICAgICAgICByZWFzb247XG4gICAgICAgIGFib3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihfLCBmbikge1xuICAgICAgICAgICAgdGhpcy5fb25hYm9ydC5wdXNoKGZuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy9AdHMtaWdub3JlXG4gICAgQUMgPSBjbGFzcyBBYm9ydENvbnRyb2xsZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHdhcm5BQ1BvbHlmaWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2lnbmFsID0gbmV3IEFTKCk7XG4gICAgICAgIGFib3J0KHJlYXNvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmFsLmFib3J0ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLnNpZ25hbC5yZWFzb24gPSByZWFzb247XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZuIG9mIHRoaXMuc2lnbmFsLl9vbmFib3J0KSB7XG4gICAgICAgICAgICAgICAgZm4ocmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2lnbmFsLm9uYWJvcnQ/LihyZWFzb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgcHJpbnRBQ1BvbHlmaWxsV2FybmluZyA9IFBST0NFU1MuZW52Py5MUlVfQ0FDSEVfSUdOT1JFX0FDX1dBUk5JTkcgIT09ICcxJztcbiAgICBjb25zdCB3YXJuQUNQb2x5ZmlsbCA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFwcmludEFDUG9seWZpbGxXYXJuaW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwcmludEFDUG9seWZpbGxXYXJuaW5nID0gZmFsc2U7XG4gICAgICAgIGVtaXRXYXJuaW5nKCdBYm9ydENvbnRyb2xsZXIgaXMgbm90IGRlZmluZWQuIElmIHVzaW5nIGxydS1jYWNoZSBpbiAnICtcbiAgICAgICAgICAgICdub2RlIDE0LCBsb2FkIGFuIEFib3J0Q29udHJvbGxlciBwb2x5ZmlsbCBmcm9tIHRoZSAnICtcbiAgICAgICAgICAgICdgbm9kZS1hYm9ydC1jb250cm9sbGVyYCBwYWNrYWdlLiBBIG1pbmltYWwgcG9seWZpbGwgaXMgJyArXG4gICAgICAgICAgICAncHJvdmlkZWQgZm9yIHVzZSBieSBMUlVDYWNoZS5mZXRjaCgpLCBidXQgaXQgc2hvdWxkIG5vdCBiZSAnICtcbiAgICAgICAgICAgICdyZWxpZWQgdXBvbiBpbiBvdGhlciBjb250ZXh0cyAoZWcsIHBhc3NpbmcgaXQgdG8gb3RoZXIgQVBJcyB0aGF0ICcgK1xuICAgICAgICAgICAgJ3VzZSBBYm9ydENvbnRyb2xsZXIvQWJvcnRTaWduYWwgbWlnaHQgaGF2ZSB1bmRlc2lyYWJsZSBlZmZlY3RzKS4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBkaXNhYmxlIHRoaXMgd2l0aCBMUlVfQ0FDSEVfSUdOT1JFX0FDX1dBUk5JTkc9MSBpbiB0aGUgZW52LicsICdOT19BQk9SVF9DT05UUk9MTEVSJywgJ0VOT1RTVVAnLCB3YXJuQUNQb2x5ZmlsbCk7XG4gICAgfTtcbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5jb25zdCBzaG91bGRXYXJuID0gKGNvZGUpID0+ICF3YXJuZWQuaGFzKGNvZGUpO1xuY29uc3QgVFlQRSA9IFN5bWJvbCgndHlwZScpO1xuY29uc3QgaXNQb3NJbnQgPSAobikgPT4gbiAmJiBuID09PSBNYXRoLmZsb29yKG4pICYmIG4gPiAwICYmIGlzRmluaXRlKG4pO1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG4vLyBUaGlzIGlzIGEgbGl0dGxlIGJpdCByaWRpY3Vsb3VzLCB0YmguXG4vLyBUaGUgbWF4aW11bSBhcnJheSBsZW5ndGggaXMgMl4zMi0xIG9yIHRoZXJlYWJvdXRzIG9uIG1vc3QgSlMgaW1wbHMuXG4vLyBBbmQgd2VsbCBiZWZvcmUgdGhhdCBwb2ludCwgeW91J3JlIGNhY2hpbmcgdGhlIGVudGlyZSB3b3JsZCwgSSBtZWFuLFxuLy8gdGhhdCdzIH4zMkdCIG9mIGp1c3QgaW50ZWdlcnMgZm9yIHRoZSBuZXh0L3ByZXYgbGlua3MsIHBsdXMgd2hhdGV2ZXJcbi8vIGVsc2UgdG8gaG9sZCB0aGF0IG1hbnkga2V5cyBhbmQgdmFsdWVzLiAgSnVzdCBmaWxsaW5nIHRoZSBtZW1vcnkgd2l0aFxuLy8gemVyb2VzIGF0IGluaXQgdGltZSBpcyBicnV0YWwgd2hlbiB5b3UgZ2V0IHRoYXQgYmlnLlxuLy8gQnV0IHdoeSBub3QgYmUgY29tcGxldGU/XG4vLyBNYXliZSBpbiB0aGUgZnV0dXJlLCB0aGVzZSBsaW1pdHMgd2lsbCBoYXZlIGV4cGFuZGVkLlxuY29uc3QgZ2V0VWludEFycmF5ID0gKG1heCkgPT4gIWlzUG9zSW50KG1heClcbiAgICA/IG51bGxcbiAgICA6IG1heCA8PSBNYXRoLnBvdygyLCA4KVxuICAgICAgICA/IFVpbnQ4QXJyYXlcbiAgICAgICAgOiBtYXggPD0gTWF0aC5wb3coMiwgMTYpXG4gICAgICAgICAgICA/IFVpbnQxNkFycmF5XG4gICAgICAgICAgICA6IG1heCA8PSBNYXRoLnBvdygyLCAzMilcbiAgICAgICAgICAgICAgICA/IFVpbnQzMkFycmF5XG4gICAgICAgICAgICAgICAgOiBtYXggPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICAgICAgICAgICAgICAgICAgPyBaZXJvQXJyYXlcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuLyogYzggaWdub3JlIHN0b3AgKi9cbmNsYXNzIFplcm9BcnJheSBleHRlbmRzIEFycmF5IHtcbiAgICBjb25zdHJ1Y3RvcihzaXplKSB7XG4gICAgICAgIHN1cGVyKHNpemUpO1xuICAgICAgICB0aGlzLmZpbGwoMCk7XG4gICAgfVxufVxuY2xhc3MgU3RhY2sge1xuICAgIGhlYXA7XG4gICAgbGVuZ3RoO1xuICAgIC8vIHByaXZhdGUgY29uc3RydWN0b3JcbiAgICBzdGF0aWMgI2NvbnN0cnVjdGluZyA9IGZhbHNlO1xuICAgIHN0YXRpYyBjcmVhdGUobWF4KSB7XG4gICAgICAgIGNvbnN0IEhlYXBDbHMgPSBnZXRVaW50QXJyYXkobWF4KTtcbiAgICAgICAgaWYgKCFIZWFwQ2xzKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBTdGFjay4jY29uc3RydWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcyA9IG5ldyBTdGFjayhtYXgsIEhlYXBDbHMpO1xuICAgICAgICBTdGFjay4jY29uc3RydWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihtYXgsIEhlYXBDbHMpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghU3RhY2suI2NvbnN0cnVjdGluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5zdGFudGlhdGUgU3RhY2sgdXNpbmcgU3RhY2suY3JlYXRlKG4pJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy5oZWFwID0gbmV3IEhlYXBDbHMobWF4KTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBwdXNoKG4pIHtcbiAgICAgICAgdGhpcy5oZWFwW3RoaXMubGVuZ3RoKytdID0gbjtcbiAgICB9XG4gICAgcG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFwWy0tdGhpcy5sZW5ndGhdO1xuICAgIH1cbn1cbi8qKlxuICogRGVmYXVsdCBleHBvcnQsIHRoZSB0aGluZyB5b3UncmUgdXNpbmcgdGhpcyBtb2R1bGUgdG8gZ2V0LlxuICpcbiAqIEFsbCBwcm9wZXJ0aWVzIGZyb20gdGhlIG9wdGlvbnMgb2JqZWN0ICh3aXRoIHRoZSBleGNlcHRpb24gb2ZcbiAqIHtAbGluayBPcHRpb25zQmFzZS5tYXh9IGFuZCB7QGxpbmsgT3B0aW9uc0Jhc2UubWF4U2l6ZX0pIGFyZSBhZGRlZCBhc1xuICogbm9ybWFsIHB1YmxpYyBtZW1iZXJzLiAoYG1heGAgYW5kIGBtYXhCYXNlYCBhcmUgcmVhZC1vbmx5IGdldHRlcnMuKVxuICogQ2hhbmdpbmcgYW55IG9mIHRoZXNlIHdpbGwgYWx0ZXIgdGhlIGRlZmF1bHRzIGZvciBzdWJzZXF1ZW50IG1ldGhvZCBjYWxscyxcbiAqIGJ1dCBpcyBvdGhlcndpc2Ugc2FmZS5cbiAqL1xuY2xhc3MgTFJVQ2FjaGUge1xuICAgIC8vIHByb3BlcnRpZXMgY29taW5nIGluIGZyb20gdGhlIG9wdGlvbnMgb2YgdGhlc2UsIG9ubHkgbWF4IGFuZCBtYXhTaXplXG4gICAgLy8gcmVhbGx5ICpuZWVkKiB0byBiZSBwcm90ZWN0ZWQuIFRoZSByZXN0IGNhbiBiZSBtb2RpZmllZCwgYXMgdGhleSBqdXN0XG4gICAgLy8gc2V0IGRlZmF1bHRzIGZvciB2YXJpb3VzIG1ldGhvZHMuXG4gICAgI21heDtcbiAgICAjbWF4U2l6ZTtcbiAgICAjZGlzcG9zZTtcbiAgICAjZGlzcG9zZUFmdGVyO1xuICAgICNmZXRjaE1ldGhvZDtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UudHRsfVxuICAgICAqL1xuICAgIHR0bDtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UudHRsUmVzb2x1dGlvbn1cbiAgICAgKi9cbiAgICB0dGxSZXNvbHV0aW9uO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS50dGxBdXRvcHVyZ2V9XG4gICAgICovXG4gICAgdHRsQXV0b3B1cmdlO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS51cGRhdGVBZ2VPbkdldH1cbiAgICAgKi9cbiAgICB1cGRhdGVBZ2VPbkdldDtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UudXBkYXRlQWdlT25IYXN9XG4gICAgICovXG4gICAgdXBkYXRlQWdlT25IYXM7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmFsbG93U3RhbGV9XG4gICAgICovXG4gICAgYWxsb3dTdGFsZTtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2Uubm9EaXNwb3NlT25TZXR9XG4gICAgICovXG4gICAgbm9EaXNwb3NlT25TZXQ7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLm5vVXBkYXRlVFRMfVxuICAgICAqL1xuICAgIG5vVXBkYXRlVFRMO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5tYXhFbnRyeVNpemV9XG4gICAgICovXG4gICAgbWF4RW50cnlTaXplO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5zaXplQ2FsY3VsYXRpb259XG4gICAgICovXG4gICAgc2l6ZUNhbGN1bGF0aW9uO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5ub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb259XG4gICAgICovXG4gICAgbm9EZWxldGVPbkZldGNoUmVqZWN0aW9uO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5ub0RlbGV0ZU9uU3RhbGVHZXR9XG4gICAgICovXG4gICAgbm9EZWxldGVPblN0YWxlR2V0O1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5hbGxvd1N0YWxlT25GZXRjaEFib3J0fVxuICAgICAqL1xuICAgIGFsbG93U3RhbGVPbkZldGNoQWJvcnQ7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9ufVxuICAgICAqL1xuICAgIGFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5pZ25vcmVGZXRjaEFib3J0fVxuICAgICAqL1xuICAgIGlnbm9yZUZldGNoQWJvcnQ7XG4gICAgLy8gY29tcHV0ZWQgcHJvcGVydGllc1xuICAgICNzaXplO1xuICAgICNjYWxjdWxhdGVkU2l6ZTtcbiAgICAja2V5TWFwO1xuICAgICNrZXlMaXN0O1xuICAgICN2YWxMaXN0O1xuICAgICNuZXh0O1xuICAgICNwcmV2O1xuICAgICNoZWFkO1xuICAgICN0YWlsO1xuICAgICNmcmVlO1xuICAgICNkaXNwb3NlZDtcbiAgICAjc2l6ZXM7XG4gICAgI3N0YXJ0cztcbiAgICAjdHRscztcbiAgICAjaGFzRGlzcG9zZTtcbiAgICAjaGFzRmV0Y2hNZXRob2Q7XG4gICAgI2hhc0Rpc3Bvc2VBZnRlcjtcbiAgICAvKipcbiAgICAgKiBEbyBub3QgY2FsbCB0aGlzIG1ldGhvZCB1bmxlc3MgeW91IG5lZWQgdG8gaW5zcGVjdCB0aGVcbiAgICAgKiBpbm5lciB3b3JraW5ncyBvZiB0aGUgY2FjaGUuICBJZiBhbnl0aGluZyByZXR1cm5lZCBieSB0aGlzXG4gICAgICogb2JqZWN0IGlzIG1vZGlmaWVkIGluIGFueSB3YXksIHN0cmFuZ2UgYnJlYWthZ2UgbWF5IG9jY3VyLlxuICAgICAqXG4gICAgICogVGhlc2UgZmllbGRzIGFyZSBwcml2YXRlIGZvciBhIHJlYXNvbiFcbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyB1bnNhZmVFeHBvc2VJbnRlcm5hbHMoYykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gcHJvcGVydGllc1xuICAgICAgICAgICAgc3RhcnRzOiBjLiNzdGFydHMsXG4gICAgICAgICAgICB0dGxzOiBjLiN0dGxzLFxuICAgICAgICAgICAgc2l6ZXM6IGMuI3NpemVzLFxuICAgICAgICAgICAga2V5TWFwOiBjLiNrZXlNYXAsXG4gICAgICAgICAgICBrZXlMaXN0OiBjLiNrZXlMaXN0LFxuICAgICAgICAgICAgdmFsTGlzdDogYy4jdmFsTGlzdCxcbiAgICAgICAgICAgIG5leHQ6IGMuI25leHQsXG4gICAgICAgICAgICBwcmV2OiBjLiNwcmV2LFxuICAgICAgICAgICAgZ2V0IGhlYWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMuI2hlYWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHRhaWwoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMuI3RhaWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJlZTogYy4jZnJlZSxcbiAgICAgICAgICAgIC8vIG1ldGhvZHNcbiAgICAgICAgICAgIGlzQmFja2dyb3VuZEZldGNoOiAocCkgPT4gYy4jaXNCYWNrZ3JvdW5kRmV0Y2gocCksXG4gICAgICAgICAgICBiYWNrZ3JvdW5kRmV0Y2g6IChrLCBpbmRleCwgb3B0aW9ucywgY29udGV4dCkgPT4gYy4jYmFja2dyb3VuZEZldGNoKGssIGluZGV4LCBvcHRpb25zLCBjb250ZXh0KSxcbiAgICAgICAgICAgIG1vdmVUb1RhaWw6IChpbmRleCkgPT4gYy4jbW92ZVRvVGFpbChpbmRleCksXG4gICAgICAgICAgICBpbmRleGVzOiAob3B0aW9ucykgPT4gYy4jaW5kZXhlcyhvcHRpb25zKSxcbiAgICAgICAgICAgIHJpbmRleGVzOiAob3B0aW9ucykgPT4gYy4jcmluZGV4ZXMob3B0aW9ucyksXG4gICAgICAgICAgICBpc1N0YWxlOiAoaW5kZXgpID0+IGMuI2lzU3RhbGUoaW5kZXgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBQcm90ZWN0ZWQgcmVhZC1vbmx5IG1lbWJlcnNcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UubWF4fSAocmVhZC1vbmx5KVxuICAgICAqL1xuICAgIGdldCBtYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNtYXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5tYXhTaXplfSAocmVhZC1vbmx5KVxuICAgICAqL1xuICAgIGdldCBtYXhTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbWF4U2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHRvdGFsIGNvbXB1dGVkIHNpemUgb2YgaXRlbXMgaW4gdGhlIGNhY2hlIChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IGNhbGN1bGF0ZWRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY2FsY3VsYXRlZFNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgaXRlbXMgc3RvcmVkIGluIHRoZSBjYWNoZSAocmVhZC1vbmx5KVxuICAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmZldGNoTWV0aG9kfSAocmVhZC1vbmx5KVxuICAgICAqL1xuICAgIGdldCBmZXRjaE1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZldGNoTWV0aG9kO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UuZGlzcG9zZX0gKHJlYWQtb25seSlcbiAgICAgKi9cbiAgICBnZXQgZGlzcG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Rpc3Bvc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5kaXNwb3NlQWZ0ZXJ9IChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IGRpc3Bvc2VBZnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Rpc3Bvc2VBZnRlcjtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IG1heCA9IDAsIHR0bCwgdHRsUmVzb2x1dGlvbiA9IDEsIHR0bEF1dG9wdXJnZSwgdXBkYXRlQWdlT25HZXQsIHVwZGF0ZUFnZU9uSGFzLCBhbGxvd1N0YWxlLCBkaXNwb3NlLCBkaXNwb3NlQWZ0ZXIsIG5vRGlzcG9zZU9uU2V0LCBub1VwZGF0ZVRUTCwgbWF4U2l6ZSA9IDAsIG1heEVudHJ5U2l6ZSA9IDAsIHNpemVDYWxjdWxhdGlvbiwgZmV0Y2hNZXRob2QsIG5vRGVsZXRlT25GZXRjaFJlamVjdGlvbiwgbm9EZWxldGVPblN0YWxlR2V0LCBhbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbiwgYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCwgaWdub3JlRmV0Y2hBYm9ydCwgfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChtYXggIT09IDAgJiYgIWlzUG9zSW50KG1heCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBvcHRpb24gbXVzdCBiZSBhIG5vbm5lZ2F0aXZlIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBVaW50QXJyYXkgPSBtYXggPyBnZXRVaW50QXJyYXkobWF4KSA6IEFycmF5O1xuICAgICAgICBpZiAoIVVpbnRBcnJheSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1heCB2YWx1ZTogJyArIG1heCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbWF4ID0gbWF4O1xuICAgICAgICB0aGlzLiNtYXhTaXplID0gbWF4U2l6ZTtcbiAgICAgICAgdGhpcy5tYXhFbnRyeVNpemUgPSBtYXhFbnRyeVNpemUgfHwgdGhpcy4jbWF4U2l6ZTtcbiAgICAgICAgdGhpcy5zaXplQ2FsY3VsYXRpb24gPSBzaXplQ2FsY3VsYXRpb247XG4gICAgICAgIGlmICh0aGlzLnNpemVDYWxjdWxhdGlvbikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLiNtYXhTaXplICYmICF0aGlzLm1heEVudHJ5U2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCBzZXQgc2l6ZUNhbGN1bGF0aW9uIHdpdGhvdXQgc2V0dGluZyBtYXhTaXplIG9yIG1heEVudHJ5U2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNpemVDYWxjdWxhdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemVDYWxjdWxhdGlvbiBzZXQgdG8gbm9uLWZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZldGNoTWV0aG9kICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHR5cGVvZiBmZXRjaE1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmV0Y2hNZXRob2QgbXVzdCBiZSBhIGZ1bmN0aW9uIGlmIHNwZWNpZmllZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2ZldGNoTWV0aG9kID0gZmV0Y2hNZXRob2Q7XG4gICAgICAgIHRoaXMuI2hhc0ZldGNoTWV0aG9kID0gISFmZXRjaE1ldGhvZDtcbiAgICAgICAgdGhpcy4ja2V5TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNrZXlMaXN0ID0gbmV3IEFycmF5KG1heCkuZmlsbCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLiN2YWxMaXN0ID0gbmV3IEFycmF5KG1heCkuZmlsbCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLiNuZXh0ID0gbmV3IFVpbnRBcnJheShtYXgpO1xuICAgICAgICB0aGlzLiNwcmV2ID0gbmV3IFVpbnRBcnJheShtYXgpO1xuICAgICAgICB0aGlzLiNoZWFkID0gMDtcbiAgICAgICAgdGhpcy4jdGFpbCA9IDA7XG4gICAgICAgIHRoaXMuI2ZyZWUgPSBTdGFjay5jcmVhdGUobWF4KTtcbiAgICAgICAgdGhpcy4jc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuI2NhbGN1bGF0ZWRTaXplID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiBkaXNwb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLiNkaXNwb3NlID0gZGlzcG9zZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRpc3Bvc2VBZnRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy4jZGlzcG9zZUFmdGVyID0gZGlzcG9zZUFmdGVyO1xuICAgICAgICAgICAgdGhpcy4jZGlzcG9zZWQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VBZnRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2hhc0Rpc3Bvc2UgPSAhIXRoaXMuI2Rpc3Bvc2U7XG4gICAgICAgIHRoaXMuI2hhc0Rpc3Bvc2VBZnRlciA9ICEhdGhpcy4jZGlzcG9zZUFmdGVyO1xuICAgICAgICB0aGlzLm5vRGlzcG9zZU9uU2V0ID0gISFub0Rpc3Bvc2VPblNldDtcbiAgICAgICAgdGhpcy5ub1VwZGF0ZVRUTCA9ICEhbm9VcGRhdGVUVEw7XG4gICAgICAgIHRoaXMubm9EZWxldGVPbkZldGNoUmVqZWN0aW9uID0gISFub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb247XG4gICAgICAgIHRoaXMuYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb24gPSAhIWFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uO1xuICAgICAgICB0aGlzLmFsbG93U3RhbGVPbkZldGNoQWJvcnQgPSAhIWFsbG93U3RhbGVPbkZldGNoQWJvcnQ7XG4gICAgICAgIHRoaXMuaWdub3JlRmV0Y2hBYm9ydCA9ICEhaWdub3JlRmV0Y2hBYm9ydDtcbiAgICAgICAgLy8gTkI6IG1heEVudHJ5U2l6ZSBpcyBzZXQgdG8gbWF4U2l6ZSBpZiBpdCdzIHNldFxuICAgICAgICBpZiAodGhpcy5tYXhFbnRyeVNpemUgIT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNtYXhTaXplICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Bvc0ludCh0aGlzLiNtYXhTaXplKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhTaXplIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGlmIHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQb3NJbnQodGhpcy5tYXhFbnRyeVNpemUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4RW50cnlTaXplIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGlmIHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jaW5pdGlhbGl6ZVNpemVUcmFja2luZygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsb3dTdGFsZSA9ICEhYWxsb3dTdGFsZTtcbiAgICAgICAgdGhpcy5ub0RlbGV0ZU9uU3RhbGVHZXQgPSAhIW5vRGVsZXRlT25TdGFsZUdldDtcbiAgICAgICAgdGhpcy51cGRhdGVBZ2VPbkdldCA9ICEhdXBkYXRlQWdlT25HZXQ7XG4gICAgICAgIHRoaXMudXBkYXRlQWdlT25IYXMgPSAhIXVwZGF0ZUFnZU9uSGFzO1xuICAgICAgICB0aGlzLnR0bFJlc29sdXRpb24gPVxuICAgICAgICAgICAgaXNQb3NJbnQodHRsUmVzb2x1dGlvbikgfHwgdHRsUmVzb2x1dGlvbiA9PT0gMFxuICAgICAgICAgICAgICAgID8gdHRsUmVzb2x1dGlvblxuICAgICAgICAgICAgICAgIDogMTtcbiAgICAgICAgdGhpcy50dGxBdXRvcHVyZ2UgPSAhIXR0bEF1dG9wdXJnZTtcbiAgICAgICAgdGhpcy50dGwgPSB0dGwgfHwgMDtcbiAgICAgICAgaWYgKHRoaXMudHRsKSB7XG4gICAgICAgICAgICBpZiAoIWlzUG9zSW50KHRoaXMudHRsKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3R0bCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBpZiBzcGVjaWZpZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2luaXRpYWxpemVUVExUcmFja2luZygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvIG5vdCBhbGxvdyBjb21wbGV0ZWx5IHVuYm91bmRlZCBjYWNoZXNcbiAgICAgICAgaWYgKHRoaXMuI21heCA9PT0gMCAmJiB0aGlzLnR0bCA9PT0gMCAmJiB0aGlzLiNtYXhTaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBdCBsZWFzdCBvbmUgb2YgbWF4LCBtYXhTaXplLCBvciB0dGwgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudHRsQXV0b3B1cmdlICYmICF0aGlzLiNtYXggJiYgIXRoaXMuI21heFNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSAnTFJVX0NBQ0hFX1VOQk9VTkRFRCc7XG4gICAgICAgICAgICBpZiAoc2hvdWxkV2Fybihjb2RlKSkge1xuICAgICAgICAgICAgICAgIHdhcm5lZC5hZGQoY29kZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gJ1RUTCBjYWNoaW5nIHdpdGhvdXQgdHRsQXV0b3B1cmdlLCBtYXgsIG9yIG1heFNpemUgY2FuICcgK1xuICAgICAgICAgICAgICAgICAgICAncmVzdWx0IGluIHVuYm91bmRlZCBtZW1vcnkgY29uc3VtcHRpb24uJztcbiAgICAgICAgICAgICAgICBlbWl0V2FybmluZyhtc2csICdVbmJvdW5kZWRDYWNoZVdhcm5pbmcnLCBjb2RlLCBMUlVDYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSByZW1haW5pbmcgVFRMIHRpbWUgZm9yIGEgZ2l2ZW4gZW50cnkga2V5XG4gICAgICovXG4gICAgZ2V0UmVtYWluaW5nVFRMKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy4ja2V5TWFwLmhhcyhrZXkpID8gSW5maW5pdHkgOiAwO1xuICAgIH1cbiAgICAjaW5pdGlhbGl6ZVRUTFRyYWNraW5nKCkge1xuICAgICAgICBjb25zdCB0dGxzID0gbmV3IFplcm9BcnJheSh0aGlzLiNtYXgpO1xuICAgICAgICBjb25zdCBzdGFydHMgPSBuZXcgWmVyb0FycmF5KHRoaXMuI21heCk7XG4gICAgICAgIHRoaXMuI3R0bHMgPSB0dGxzO1xuICAgICAgICB0aGlzLiNzdGFydHMgPSBzdGFydHM7XG4gICAgICAgIHRoaXMuI3NldEl0ZW1UVEwgPSAoaW5kZXgsIHR0bCwgc3RhcnQgPSBwZXJmLm5vdygpKSA9PiB7XG4gICAgICAgICAgICBzdGFydHNbaW5kZXhdID0gdHRsICE9PSAwID8gc3RhcnQgOiAwO1xuICAgICAgICAgICAgdHRsc1tpbmRleF0gPSB0dGw7XG4gICAgICAgICAgICBpZiAodHRsICE9PSAwICYmIHRoaXMudHRsQXV0b3B1cmdlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jaXNTdGFsZShpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlKHRoaXMuI2tleUxpc3RbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHR0bCArIDEpO1xuICAgICAgICAgICAgICAgIC8vIHVucmVmKCkgbm90IHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zXG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgaWYgKHQudW5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdC51bnJlZigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLiN1cGRhdGVJdGVtQWdlID0gaW5kZXggPT4ge1xuICAgICAgICAgICAgc3RhcnRzW2luZGV4XSA9IHR0bHNbaW5kZXhdICE9PSAwID8gcGVyZi5ub3coKSA6IDA7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI3N0YXR1c1RUTCA9IChzdGF0dXMsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAodHRsc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0dGwgPSB0dGxzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IHN0YXJ0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgc3RhdHVzLnR0bCA9IHR0bDtcbiAgICAgICAgICAgICAgICBzdGF0dXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICBzdGF0dXMubm93ID0gY2FjaGVkTm93IHx8IGdldE5vdygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFnZSA9IHN0YXR1cy5ub3cgLSBzdGFydDtcbiAgICAgICAgICAgICAgICBzdGF0dXMucmVtYWluaW5nVFRMID0gdHRsIC0gYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBkZWJvdW5jZSBjYWxscyB0byBwZXJmLm5vdygpIHRvIDFzIHNvIHdlJ3JlIG5vdCBoaXR0aW5nXG4gICAgICAgIC8vIHRoYXQgY29zdGx5IGNhbGwgcmVwZWF0ZWRseS5cbiAgICAgICAgbGV0IGNhY2hlZE5vdyA9IDA7XG4gICAgICAgIGNvbnN0IGdldE5vdyA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBwZXJmLm5vdygpO1xuICAgICAgICAgICAgaWYgKHRoaXMudHRsUmVzb2x1dGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICBjYWNoZWROb3cgPSBuO1xuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBzZXRUaW1lb3V0KCgpID0+IChjYWNoZWROb3cgPSAwKSwgdGhpcy50dGxSZXNvbHV0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyBub3QgYXZhaWxhYmxlIG9uIGFsbCBwbGF0Zm9ybXNcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICBpZiAodC51bnJlZikge1xuICAgICAgICAgICAgICAgICAgICB0LnVucmVmKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRSZW1haW5pbmdUVEwgPSBrZXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLiNrZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHRsID0gdHRsc1tpbmRleF07XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHN0YXJ0c1tpbmRleF07XG4gICAgICAgICAgICBpZiAodHRsID09PSAwIHx8IHN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWdlID0gKGNhY2hlZE5vdyB8fCBnZXROb3coKSkgLSBzdGFydDtcbiAgICAgICAgICAgIHJldHVybiB0dGwgLSBhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI2lzU3RhbGUgPSBpbmRleCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHR0bHNbaW5kZXhdICE9PSAwICYmXG4gICAgICAgICAgICAgICAgc3RhcnRzW2luZGV4XSAhPT0gMCAmJlxuICAgICAgICAgICAgICAgIChjYWNoZWROb3cgfHwgZ2V0Tm93KCkpIC0gc3RhcnRzW2luZGV4XSA+IHR0bHNbaW5kZXhdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gY29uZGl0aW9uYWxseSBzZXQgcHJpdmF0ZSBtZXRob2RzIHJlbGF0ZWQgdG8gVFRMXG4gICAgI3VwZGF0ZUl0ZW1BZ2UgPSAoKSA9PiB7IH07XG4gICAgI3N0YXR1c1RUTCA9ICgpID0+IHsgfTtcbiAgICAjc2V0SXRlbVRUTCA9ICgpID0+IHsgfTtcbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICNpc1N0YWxlID0gKCkgPT4gZmFsc2U7XG4gICAgI2luaXRpYWxpemVTaXplVHJhY2tpbmcoKSB7XG4gICAgICAgIGNvbnN0IHNpemVzID0gbmV3IFplcm9BcnJheSh0aGlzLiNtYXgpO1xuICAgICAgICB0aGlzLiNjYWxjdWxhdGVkU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuI3NpemVzID0gc2l6ZXM7XG4gICAgICAgIHRoaXMuI3JlbW92ZUl0ZW1TaXplID0gaW5kZXggPT4ge1xuICAgICAgICAgICAgdGhpcy4jY2FsY3VsYXRlZFNpemUgLT0gc2l6ZXNbaW5kZXhdO1xuICAgICAgICAgICAgc2l6ZXNbaW5kZXhdID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy4jcmVxdWlyZVNpemUgPSAoaywgdiwgc2l6ZSwgc2l6ZUNhbGN1bGF0aW9uKSA9PiB7XG4gICAgICAgICAgICAvLyBwcm92aXNpb25hbGx5IGFjY2VwdCBiYWNrZ3JvdW5kIGZldGNoZXMuXG4gICAgICAgICAgICAvLyBhY3R1YWwgdmFsdWUgc2l6ZSB3aWxsIGJlIGNoZWNrZWQgd2hlbiB0aGV5IHJldHVybi5cbiAgICAgICAgICAgIGlmICh0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1Bvc0ludChzaXplKSkge1xuICAgICAgICAgICAgICAgIGlmIChzaXplQ2FsY3VsYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzaXplQ2FsY3VsYXRpb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemVDYWxjdWxhdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzaXplID0gc2l6ZUNhbGN1bGF0aW9uKHYsIGspO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUG9zSW50KHNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplQ2FsY3VsYXRpb24gcmV0dXJuIGludmFsaWQgKGV4cGVjdCBwb3NpdGl2ZSBpbnRlZ2VyKScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHNpemUgdmFsdWUgKG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlcikuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1doZW4gbWF4U2l6ZSBvciBtYXhFbnRyeVNpemUgaXMgdXNlZCwgc2l6ZUNhbGN1bGF0aW9uICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29yIHNpemUgbXVzdCBiZSBzZXQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI2FkZEl0ZW1TaXplID0gKGluZGV4LCBzaXplLCBzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIHNpemVzW2luZGV4XSA9IHNpemU7XG4gICAgICAgICAgICBpZiAodGhpcy4jbWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heFNpemUgPSB0aGlzLiNtYXhTaXplIC0gc2l6ZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLiNjYWxjdWxhdGVkU2l6ZSA+IG1heFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jZXZpY3QodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jY2FsY3VsYXRlZFNpemUgKz0gc2l6ZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5lbnRyeVNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgIHN0YXR1cy50b3RhbENhbGN1bGF0ZWRTaXplID0gdGhpcy4jY2FsY3VsYXRlZFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgICNyZW1vdmVJdGVtU2l6ZSA9IF9pID0+IHsgfTtcbiAgICAjYWRkSXRlbVNpemUgPSAoX2ksIF9zLCBfc3QpID0+IHsgfTtcbiAgICAjcmVxdWlyZVNpemUgPSAoX2ssIF92LCBzaXplLCBzaXplQ2FsY3VsYXRpb24pID0+IHtcbiAgICAgICAgaWYgKHNpemUgfHwgc2l6ZUNhbGN1bGF0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3Qgc2V0IHNpemUgd2l0aG91dCBzZXR0aW5nIG1heFNpemUgb3IgbWF4RW50cnlTaXplIG9uIGNhY2hlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICAqI2luZGV4ZXMoeyBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlIH0gPSB7fSkge1xuICAgICAgICBpZiAodGhpcy4jc2l6ZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuI3RhaWw7IHRydWU7KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLiNpc1ZhbGlkSW5kZXgoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhbGxvd1N0YWxlIHx8ICF0aGlzLiNpc1N0YWxlKGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09PSB0aGlzLiNoZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IHRoaXMuI3ByZXZbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgICojcmluZGV4ZXMoeyBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlIH0gPSB7fSkge1xuICAgICAgICBpZiAodGhpcy4jc2l6ZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuI2hlYWQ7IHRydWU7KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLiNpc1ZhbGlkSW5kZXgoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhbGxvd1N0YWxlIHx8ICF0aGlzLiNpc1N0YWxlKGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09PSB0aGlzLiN0YWlsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IHRoaXMuI25leHRbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgICNpc1ZhbGlkSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIChpbmRleCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLiNrZXlNYXAuZ2V0KHRoaXMuI2tleUxpc3RbaW5kZXhdKSA9PT0gaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBnZW5lcmF0b3IgeWllbGRpbmcgYFtrZXksIHZhbHVlXWAgcGFpcnMsXG4gICAgICogaW4gb3JkZXIgZnJvbSBtb3N0IHJlY2VudGx5IHVzZWQgdG8gbGVhc3QgcmVjZW50bHkgdXNlZC5cbiAgICAgKi9cbiAgICAqZW50cmllcygpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI2luZGV4ZXMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI3ZhbExpc3RbaV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuI2tleUxpc3RbaV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh0aGlzLiN2YWxMaXN0W2ldKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIFt0aGlzLiNrZXlMaXN0W2ldLCB0aGlzLiN2YWxMaXN0W2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnNlIG9yZGVyIHZlcnNpb24gb2Yge0BsaW5rIExSVUNhY2hlLmVudHJpZXN9XG4gICAgICpcbiAgICAgKiBSZXR1cm4gYSBnZW5lcmF0b3IgeWllbGRpbmcgYFtrZXksIHZhbHVlXWAgcGFpcnMsXG4gICAgICogaW4gb3JkZXIgZnJvbSBsZWFzdCByZWNlbnRseSB1c2VkIHRvIG1vc3QgcmVjZW50bHkgdXNlZC5cbiAgICAgKi9cbiAgICAqcmVudHJpZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNyaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jdmFsTGlzdFtpXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgdGhpcy4ja2V5TGlzdFtpXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHRoaXMuI3ZhbExpc3RbaV0pKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgW3RoaXMuI2tleUxpc3RbaV0sIHRoaXMuI3ZhbExpc3RbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGdlbmVyYXRvciB5aWVsZGluZyB0aGUga2V5cyBpbiB0aGUgY2FjaGUsXG4gICAgICogaW4gb3JkZXIgZnJvbSBtb3N0IHJlY2VudGx5IHVzZWQgdG8gbGVhc3QgcmVjZW50bHkgdXNlZC5cbiAgICAgKi9cbiAgICAqa2V5cygpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI2luZGV4ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgayA9IHRoaXMuI2tleUxpc3RbaV07XG4gICAgICAgICAgICBpZiAoayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHRoaXMuI3ZhbExpc3RbaV0pKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnNlIG9yZGVyIHZlcnNpb24gb2Yge0BsaW5rIExSVUNhY2hlLmtleXN9XG4gICAgICpcbiAgICAgKiBSZXR1cm4gYSBnZW5lcmF0b3IgeWllbGRpbmcgdGhlIGtleXMgaW4gdGhlIGNhY2hlLFxuICAgICAqIGluIG9yZGVyIGZyb20gbGVhc3QgcmVjZW50bHkgdXNlZCB0byBtb3N0IHJlY2VudGx5IHVzZWQuXG4gICAgICovXG4gICAgKnJrZXlzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jcmluZGV4ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgayA9IHRoaXMuI2tleUxpc3RbaV07XG4gICAgICAgICAgICBpZiAoayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHRoaXMuI3ZhbExpc3RbaV0pKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBnZW5lcmF0b3IgeWllbGRpbmcgdGhlIHZhbHVlcyBpbiB0aGUgY2FjaGUsXG4gICAgICogaW4gb3JkZXIgZnJvbSBtb3N0IHJlY2VudGx5IHVzZWQgdG8gbGVhc3QgcmVjZW50bHkgdXNlZC5cbiAgICAgKi9cbiAgICAqdmFsdWVzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godGhpcy4jdmFsTGlzdFtpXSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludmVyc2Ugb3JkZXIgdmVyc2lvbiBvZiB7QGxpbmsgTFJVQ2FjaGUudmFsdWVzfVxuICAgICAqXG4gICAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIHlpZWxkaW5nIHRoZSB2YWx1ZXMgaW4gdGhlIGNhY2hlLFxuICAgICAqIGluIG9yZGVyIGZyb20gbGVhc3QgcmVjZW50bHkgdXNlZCB0byBtb3N0IHJlY2VudGx5IHVzZWQuXG4gICAgICovXG4gICAgKnJ2YWx1ZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNyaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godGhpcy4jdmFsTGlzdFtpXSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGluZyBvdmVyIHRoZSBjYWNoZSBpdHNlbGYgeWllbGRzIHRoZSBzYW1lIHJlc3VsdHMgYXNcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuZW50cmllc31cbiAgICAgKi9cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIGEgdmFsdWUgZm9yIHdoaWNoIHRoZSBzdXBwbGllZCBmbiBtZXRob2QgcmV0dXJucyBhIHRydXRoeSB2YWx1ZSxcbiAgICAgKiBzaW1pbGFyIHRvIEFycmF5LmZpbmQoKS4gIGZuIGlzIGNhbGxlZCBhcyBmbih2YWx1ZSwga2V5LCBjYWNoZSkuXG4gICAgICovXG4gICAgZmluZChmbiwgZ2V0T3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KVxuICAgICAgICAgICAgICAgID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICAgICAgICAgIDogdjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGZuKHZhbHVlLCB0aGlzLiNrZXlMaXN0W2ldLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLiNrZXlMaXN0W2ldLCBnZXRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIHRoZSBzdXBwbGllZCBmdW5jdGlvbiBvbiBlYWNoIGl0ZW0gaW4gdGhlIGNhY2hlLCBpbiBvcmRlciBmcm9tXG4gICAgICogbW9zdCByZWNlbnRseSB1c2VkIHRvIGxlYXN0IHJlY2VudGx5IHVzZWQuICBmbiBpcyBjYWxsZWQgYXNcbiAgICAgKiBmbih2YWx1ZSwga2V5LCBjYWNoZSkuICBEb2VzIG5vdCB1cGRhdGUgYWdlIG9yIHJlY2VudHkgb2YgdXNlLlxuICAgICAqIERvZXMgbm90IGl0ZXJhdGUgb3ZlciBzdGFsZSB2YWx1ZXMuXG4gICAgICovXG4gICAgZm9yRWFjaChmbiwgdGhpc3AgPSB0aGlzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KVxuICAgICAgICAgICAgICAgID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICAgICAgICAgIDogdjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzcCwgdmFsdWUsIHRoaXMuI2tleUxpc3RbaV0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIHtAbGluayBMUlVDYWNoZS5mb3JFYWNofSBidXQgaXRlbXMgYXJlIGl0ZXJhdGVkIG92ZXIgaW5cbiAgICAgKiByZXZlcnNlIG9yZGVyLiAgKGllLCBsZXNzIHJlY2VudGx5IHVzZWQgaXRlbXMgYXJlIGl0ZXJhdGVkIG92ZXIgZmlyc3QuKVxuICAgICAqL1xuICAgIHJmb3JFYWNoKGZuLCB0aGlzcCA9IHRoaXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI3JpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KVxuICAgICAgICAgICAgICAgID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICAgICAgICAgIDogdjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzcCwgdmFsdWUsIHRoaXMuI2tleUxpc3RbaV0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhbnkgc3RhbGUgZW50cmllcy4gUmV0dXJucyB0cnVlIGlmIGFueXRoaW5nIHdhcyByZW1vdmVkLFxuICAgICAqIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwdXJnZVN0YWxlKCkge1xuICAgICAgICBsZXQgZGVsZXRlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jcmluZGV4ZXMoeyBhbGxvd1N0YWxlOiB0cnVlIH0pKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jaXNTdGFsZShpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlKHRoaXMuI2tleUxpc3RbaV0pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWxldGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgW2tleSwge0BsaW5rIExSVUNhY2hlLkVudHJ5fV0gdHVwbGVzIHdoaWNoIGNhbiBiZVxuICAgICAqIHBhc3NlZCB0byBjYWNoZS5sb2FkKClcbiAgICAgKi9cbiAgICBkdW1wKCkge1xuICAgICAgICBjb25zdCBhcnIgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI2luZGV4ZXMoeyBhbGxvd1N0YWxlOiB0cnVlIH0pKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLiNrZXlMaXN0W2ldO1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpXG4gICAgICAgICAgICAgICAgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgICAgICAgICAgOiB2O1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwga2V5ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IHsgdmFsdWUgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLiN0dGxzICYmIHRoaXMuI3N0YXJ0cykge1xuICAgICAgICAgICAgICAgIGVudHJ5LnR0bCA9IHRoaXMuI3R0bHNbaV07XG4gICAgICAgICAgICAgICAgLy8gYWx3YXlzIGR1bXAgdGhlIHN0YXJ0IHJlbGF0aXZlIHRvIGEgcG9ydGFibGUgdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgLy8gaXQncyBvayBmb3IgdGhpcyB0byBiZSBhIGJpdCBzbG93LCBpdCdzIGEgcmFyZSBvcGVyYXRpb24uXG4gICAgICAgICAgICAgICAgY29uc3QgYWdlID0gcGVyZi5ub3coKSAtIHRoaXMuI3N0YXJ0c1tpXTtcbiAgICAgICAgICAgICAgICBlbnRyeS5zdGFydCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAtIGFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jc2l6ZXMpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS5zaXplID0gdGhpcy4jc2l6ZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcnIudW5zaGlmdChba2V5LCBlbnRyeV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBjYWNoZSBhbmQgbG9hZCBpbiB0aGUgaXRlbXMgaW4gZW50cmllcyBpbiB0aGUgb3JkZXIgbGlzdGVkLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgc2hhcGUgb2YgdGhlIHJlc3VsdGluZyBjYWNoZSBtYXkgYmUgZGlmZmVyZW50IGlmIHRoZVxuICAgICAqIHNhbWUgb3B0aW9ucyBhcmUgbm90IHVzZWQgaW4gYm90aCBjYWNoZXMuXG4gICAgICovXG4gICAgbG9hZChhcnIpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGVudHJ5XSBvZiBhcnIpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5zdGFydCkge1xuICAgICAgICAgICAgICAgIC8vIGVudHJ5LnN0YXJ0IGlzIGEgcG9ydGFibGUgdGltZXN0YW1wLCBidXQgd2UgbWF5IGJlIHVzaW5nXG4gICAgICAgICAgICAgICAgLy8gbm9kZSdzIHBlcmZvcm1hbmNlLm5vdygpLCBzbyBjYWxjdWxhdGUgdGhlIG9mZnNldCwgc28gdGhhdFxuICAgICAgICAgICAgICAgIC8vIHdlIGdldCB0aGUgaW50ZW5kZWQgcmVtYWluaW5nIFRUTCwgbm8gbWF0dGVyIGhvdyBsb25nIGl0J3NcbiAgICAgICAgICAgICAgICAvLyBiZWVuIG9uIGljZS5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGl0J3Mgb2sgZm9yIHRoaXMgdG8gYmUgYSBiaXQgc2xvdywgaXQncyBhIHJhcmUgb3BlcmF0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnN0IGFnZSA9IERhdGUubm93KCkgLSBlbnRyeS5zdGFydDtcbiAgICAgICAgICAgICAgICBlbnRyeS5zdGFydCA9IHBlcmYubm93KCkgLSBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldChrZXksIGVudHJ5LnZhbHVlLCBlbnRyeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgdmFsdWUgdG8gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogTm90ZTogaWYgYHVuZGVmaW5lZGAgaXMgc3BlY2lmaWVkIGFzIGEgdmFsdWUsIHRoaXMgaXMgYW4gYWxpYXMgZm9yXG4gICAgICoge0BsaW5rIExSVUNhY2hlI2RlbGV0ZX1cbiAgICAgKi9cbiAgICBzZXQoaywgdiwgc2V0T3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKGspO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0dGwgPSB0aGlzLnR0bCwgc3RhcnQsIG5vRGlzcG9zZU9uU2V0ID0gdGhpcy5ub0Rpc3Bvc2VPblNldCwgc2l6ZUNhbGN1bGF0aW9uID0gdGhpcy5zaXplQ2FsY3VsYXRpb24sIHN0YXR1cywgfSA9IHNldE9wdGlvbnM7XG4gICAgICAgIGxldCB7IG5vVXBkYXRlVFRMID0gdGhpcy5ub1VwZGF0ZVRUTCB9ID0gc2V0T3B0aW9ucztcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuI3JlcXVpcmVTaXplKGssIHYsIHNldE9wdGlvbnMuc2l6ZSB8fCAwLCBzaXplQ2FsY3VsYXRpb24pO1xuICAgICAgICAvLyBpZiB0aGUgaXRlbSBkb2Vzbid0IGZpdCwgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgLy8gTkI6IG1heEVudHJ5U2l6ZSBzZXQgdG8gbWF4U2l6ZSBieSBkZWZhdWx0XG4gICAgICAgIGlmICh0aGlzLm1heEVudHJ5U2l6ZSAmJiBzaXplID4gdGhpcy5tYXhFbnRyeVNpemUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuc2V0ID0gJ21pc3MnO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5tYXhFbnRyeVNpemVFeGNlZWRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYXZlIHRvIGRlbGV0ZSwgaW4gY2FzZSBzb21ldGhpbmcgaXMgdGhlcmUgYWxyZWFkeS5cbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKGspO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy4jc2l6ZSA9PT0gMCA/IHVuZGVmaW5lZCA6IHRoaXMuI2tleU1hcC5nZXQoayk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBhZGRpdGlvblxuICAgICAgICAgICAgaW5kZXggPSAodGhpcy4jc2l6ZSA9PT0gMFxuICAgICAgICAgICAgICAgID8gdGhpcy4jdGFpbFxuICAgICAgICAgICAgICAgIDogdGhpcy4jZnJlZS5sZW5ndGggIT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLiNmcmVlLnBvcCgpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy4jc2l6ZSA9PT0gdGhpcy4jbWF4XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuI2V2aWN0KGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLiNzaXplKTtcbiAgICAgICAgICAgIHRoaXMuI2tleUxpc3RbaW5kZXhdID0gaztcbiAgICAgICAgICAgIHRoaXMuI3ZhbExpc3RbaW5kZXhdID0gdjtcbiAgICAgICAgICAgIHRoaXMuI2tleU1hcC5zZXQoaywgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy4jbmV4dFt0aGlzLiN0YWlsXSA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy4jcHJldltpbmRleF0gPSB0aGlzLiN0YWlsO1xuICAgICAgICAgICAgdGhpcy4jdGFpbCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy4jc2l6ZSsrO1xuICAgICAgICAgICAgdGhpcy4jYWRkSXRlbVNpemUoaW5kZXgsIHNpemUsIHN0YXR1cyk7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQgPSAnYWRkJztcbiAgICAgICAgICAgIG5vVXBkYXRlVFRMID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB1cGRhdGVcbiAgICAgICAgICAgIHRoaXMuI21vdmVUb1RhaWwoaW5kZXgpO1xuICAgICAgICAgICAgY29uc3Qgb2xkVmFsID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgICAgICBpZiAodiAhPT0gb2xkVmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0ZldGNoTWV0aG9kICYmIHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKG9sZFZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsLl9fYWJvcnRDb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcigncmVwbGFjZWQnKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgX19zdGFsZVdoaWxlRmV0Y2hpbmc6IHMgfSA9IG9sZFZhbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgIT09IHVuZGVmaW5lZCAmJiAhbm9EaXNwb3NlT25TZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZT8uKHMsIGssICdzZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlZD8ucHVzaChbcywgaywgJ3NldCddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghbm9EaXNwb3NlT25TZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2U/LihvbGRWYWwsIGssICdzZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlZD8ucHVzaChbb2xkVmFsLCBrLCAnc2V0J10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI3JlbW92ZUl0ZW1TaXplKGluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLiNhZGRJdGVtU2l6ZShpbmRleCwgc2l6ZSwgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLiN2YWxMaXN0W2luZGV4XSA9IHY7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0ID0gJ3JlcGxhY2UnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IG9sZFZhbCAmJiB0aGlzLiNpc0JhY2tncm91bmRGZXRjaChvbGRWYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG9sZFZhbC5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBvbGRWYWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLm9sZFZhbHVlID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnNldCA9ICd1cGRhdGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0dGwgIT09IDAgJiYgIXRoaXMuI3R0bHMpIHtcbiAgICAgICAgICAgIHRoaXMuI2luaXRpYWxpemVUVExUcmFja2luZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiN0dGxzKSB7XG4gICAgICAgICAgICBpZiAoIW5vVXBkYXRlVFRMKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jc2V0SXRlbVRUTChpbmRleCwgdHRsLCBzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgIHRoaXMuI3N0YXR1c1RUTChzdGF0dXMsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vRGlzcG9zZU9uU2V0ICYmIHRoaXMuI2hhc0Rpc3Bvc2VBZnRlciAmJiB0aGlzLiNkaXNwb3NlZCkge1xuICAgICAgICAgICAgY29uc3QgZHQgPSB0aGlzLiNkaXNwb3NlZDtcbiAgICAgICAgICAgIGxldCB0YXNrO1xuICAgICAgICAgICAgd2hpbGUgKCh0YXNrID0gZHQ/LnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZUFmdGVyPy4oLi4udGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2aWN0IHRoZSBsZWFzdCByZWNlbnRseSB1c2VkIGl0ZW0sIHJldHVybmluZyBpdHMgdmFsdWUgb3JcbiAgICAgKiBgdW5kZWZpbmVkYCBpZiBjYWNoZSBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBwb3AoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy4jc2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuI3ZhbExpc3RbdGhpcy4jaGVhZF07XG4gICAgICAgICAgICAgICAgdGhpcy4jZXZpY3QodHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbC5fX3N0YWxlV2hpbGVGZXRjaGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5fX3N0YWxlV2hpbGVGZXRjaGluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIgJiYgdGhpcy4jZGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkdCA9IHRoaXMuI2Rpc3Bvc2VkO1xuICAgICAgICAgICAgICAgIGxldCB0YXNrO1xuICAgICAgICAgICAgICAgIHdoaWxlICgodGFzayA9IGR0Py5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlQWZ0ZXI/LiguLi50YXNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2V2aWN0KGZyZWUpIHtcbiAgICAgICAgY29uc3QgaGVhZCA9IHRoaXMuI2hlYWQ7XG4gICAgICAgIGNvbnN0IGsgPSB0aGlzLiNrZXlMaXN0W2hlYWRdO1xuICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtoZWFkXTtcbiAgICAgICAgaWYgKHRoaXMuI2hhc0ZldGNoTWV0aG9kICYmIHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgICAgICB2Ll9fYWJvcnRDb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcignZXZpY3RlZCcpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLiNoYXNEaXNwb3NlIHx8IHRoaXMuI2hhc0Rpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlPy4odiwgaywgJ2V2aWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZWQ/LnB1c2goW3YsIGssICdldmljdCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNyZW1vdmVJdGVtU2l6ZShoZWFkKTtcbiAgICAgICAgLy8gaWYgd2UgYXJlbid0IGFib3V0IHRvIHVzZSB0aGUgaW5kZXgsIHRoZW4gbnVsbCB0aGVzZSBvdXRcbiAgICAgICAgaWYgKGZyZWUpIHtcbiAgICAgICAgICAgIHRoaXMuI2tleUxpc3RbaGVhZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLiN2YWxMaXN0W2hlYWRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy4jZnJlZS5wdXNoKGhlYWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNzaXplID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLiNoZWFkID0gdGhpcy4jdGFpbCA9IDA7XG4gICAgICAgICAgICB0aGlzLiNmcmVlLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNoZWFkID0gdGhpcy4jbmV4dFtoZWFkXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNrZXlNYXAuZGVsZXRlKGspO1xuICAgICAgICB0aGlzLiNzaXplLS07XG4gICAgICAgIHJldHVybiBoZWFkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIGtleSBpcyBpbiB0aGUgY2FjaGUsIHdpdGhvdXQgdXBkYXRpbmcgdGhlIHJlY2VuY3kgb2YgdXNlLlxuICAgICAqIFdpbGwgcmV0dXJuIGZhbHNlIGlmIHRoZSBpdGVtIGlzIHN0YWxlLCBldmVuIHRob3VnaCBpdCBpcyB0ZWNobmljYWxseVxuICAgICAqIGluIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIFdpbGwgbm90IHVwZGF0ZSBpdGVtIGFnZSB1bmxlc3NcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UudXBkYXRlQWdlT25IYXN9IGlzIHNldC5cbiAgICAgKi9cbiAgICBoYXMoaywgaGFzT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgdXBkYXRlQWdlT25IYXMgPSB0aGlzLnVwZGF0ZUFnZU9uSGFzLCBzdGF0dXMgfSA9IGhhc09wdGlvbnM7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy4ja2V5TWFwLmdldChrKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSAmJlxuICAgICAgICAgICAgICAgIHYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy4jaXNTdGFsZShpbmRleCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlQWdlT25IYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jdXBkYXRlSXRlbUFnZShpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmhhcyA9ICdoaXQnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNzdGF0dXNUVEwoc3RhdHVzLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmhhcyA9ICdzdGFsZSc7XG4gICAgICAgICAgICAgICAgdGhpcy4jc3RhdHVzVFRMKHN0YXR1cywgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgc3RhdHVzLmhhcyA9ICdtaXNzJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpa2Uge0BsaW5rIExSVUNhY2hlI2dldH0gYnV0IGRvZXNuJ3QgdXBkYXRlIHJlY2VuY3kgb3IgZGVsZXRlIHN0YWxlXG4gICAgICogaXRlbXMuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZSBpdGVtIGlzIHN0YWxlLCB1bmxlc3NcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UuYWxsb3dTdGFsZX0gaXMgc2V0LlxuICAgICAqL1xuICAgIHBlZWsoaywgcGVla09wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUgfSA9IHBlZWtPcHRpb25zO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuI2tleU1hcC5nZXQoayk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAoYWxsb3dTdGFsZSB8fCAhdGhpcy4jaXNTdGFsZShpbmRleCkpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgICAgICAvLyBlaXRoZXIgc3RhbGUgYW5kIGFsbG93ZWQsIG9yIGZvcmNpbmcgYSByZWZyZXNoIG9mIG5vbi1zdGFsZSB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZyA6IHY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2JhY2tncm91bmRGZXRjaChrLCBpbmRleCwgb3B0aW9ucywgY29udGV4dCkge1xuICAgICAgICBjb25zdCB2ID0gaW5kZXggPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHRoaXMuI3ZhbExpc3RbaW5kZXhdO1xuICAgICAgICBpZiAodGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjID0gbmV3IEFDKCk7XG4gICAgICAgIGNvbnN0IHsgc2lnbmFsIH0gPSBvcHRpb25zO1xuICAgICAgICAvLyB3aGVuL2lmIG91ciBBQyBzaWduYWxzLCB0aGVuIHN0b3AgbGlzdGVuaW5nIHRvIHRoZWlycy5cbiAgICAgICAgc2lnbmFsPy5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IGFjLmFib3J0KHNpZ25hbC5yZWFzb24pLCB7XG4gICAgICAgICAgICBzaWduYWw6IGFjLnNpZ25hbCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGZldGNoT3B0cyA9IHtcbiAgICAgICAgICAgIHNpZ25hbDogYWMuc2lnbmFsLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNiID0gKHYsIHVwZGF0ZUNhY2hlID0gZmFsc2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWJvcnRlZCB9ID0gYWMuc2lnbmFsO1xuICAgICAgICAgICAgY29uc3QgaWdub3JlQWJvcnQgPSBvcHRpb25zLmlnbm9yZUZldGNoQWJvcnQgJiYgdiAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFib3J0ZWQgJiYgIXVwZGF0ZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoQWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoRXJyb3IgPSBhYy5zaWduYWwucmVhc29uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlQWJvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaEFib3J0SWdub3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaFJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWJvcnRlZCAmJiAhaWdub3JlQWJvcnQgJiYgIXVwZGF0ZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoRmFpbChhYy5zaWduYWwucmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVpdGhlciB3ZSBkaWRuJ3QgYWJvcnQsIGFuZCBhcmUgc3RpbGwgaGVyZSwgb3Igd2UgZGlkLCBhbmQgaWdub3JlZFxuICAgICAgICAgICAgY29uc3QgYmYgPSBwO1xuICAgICAgICAgICAgaWYgKHRoaXMuI3ZhbExpc3RbaW5kZXhdID09PSBwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmYuX19zdGFsZVdoaWxlRmV0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI3ZhbExpc3RbaW5kZXhdID0gYmYuX19zdGFsZVdoaWxlRmV0Y2hpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZShrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhdHVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoaywgdiwgZmV0Y2hPcHRzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlYiA9IChlcikgPT4ge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hSZWplY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hFcnJvciA9IGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZldGNoRmFpbChlcik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZldGNoRmFpbCA9IChlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBhYm9ydGVkIH0gPSBhYy5zaWduYWw7XG4gICAgICAgICAgICBjb25zdCBhbGxvd1N0YWxlQWJvcnRlZCA9IGFib3J0ZWQgJiYgb3B0aW9ucy5hbGxvd1N0YWxlT25GZXRjaEFib3J0O1xuICAgICAgICAgICAgY29uc3QgYWxsb3dTdGFsZSA9IGFsbG93U3RhbGVBYm9ydGVkIHx8IG9wdGlvbnMuYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb247XG4gICAgICAgICAgICBjb25zdCBub0RlbGV0ZSA9IGFsbG93U3RhbGUgfHwgb3B0aW9ucy5ub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb247XG4gICAgICAgICAgICBjb25zdCBiZiA9IHA7XG4gICAgICAgICAgICBpZiAodGhpcy4jdmFsTGlzdFtpbmRleF0gPT09IHApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhbGxvdyBzdGFsZSBvbiBmZXRjaCByZWplY3Rpb25zLCB0aGVuIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgc3RhbGUgdmFsdWUgaXMgbm90IHJlbW92ZWQgZnJvbSB0aGUgY2FjaGUgd2hlbiB0aGUgZmV0Y2ggZmFpbHMuXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsID0gIW5vRGVsZXRlIHx8IGJmLl9fc3RhbGVXaGlsZUZldGNoaW5nID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGRlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZShrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWFsbG93U3RhbGVBYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0aWxsIHJlcGxhY2UgdGhlICpwcm9taXNlKiB3aXRoIHRoZSBzdGFsZSB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luY2Ugd2UgYXJlIGRvbmUgd2l0aCB0aGUgcHJvbWlzZSBhdCB0aGlzIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAvLyBsZWF2ZSBpdCB1bnRvdWNoZWQgaWYgd2UncmUgc3RpbGwgd2FpdGluZyBmb3IgYW5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWJvcnRlZCBiYWNrZ3JvdW5kIGZldGNoIHRoYXQgaGFzbid0IHlldCByZXR1cm5lZC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jdmFsTGlzdFtpbmRleF0gPSBiZi5fX3N0YWxlV2hpbGVGZXRjaGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxsb3dTdGFsZSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXR1cyAmJiBiZi5fX3N0YWxlV2hpbGVGZXRjaGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLnJldHVybmVkU3RhbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmYuX19zdGFsZVdoaWxlRmV0Y2hpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiZi5fX3JldHVybmVkID09PSBiZikge1xuICAgICAgICAgICAgICAgIHRocm93IGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwY2FsbCA9IChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZm1wID0gdGhpcy4jZmV0Y2hNZXRob2Q/LihrLCB2LCBmZXRjaE9wdHMpO1xuICAgICAgICAgICAgaWYgKGZtcCAmJiBmbXAgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgZm1wLnRoZW4odiA9PiByZXModiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdiksIHJlaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZ25vcmVkLCB3ZSBnbyB1bnRpbCB3ZSBmaW5pc2gsIHJlZ2FyZGxlc3MuXG4gICAgICAgICAgICAvLyBkZWZlciBjaGVjayB1bnRpbCB3ZSBhcmUgYWN0dWFsbHkgYWJvcnRpbmcsXG4gICAgICAgICAgICAvLyBzbyBmZXRjaE1ldGhvZCBjYW4gb3ZlcnJpZGUuXG4gICAgICAgICAgICBhYy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmlnbm9yZUZldGNoQWJvcnQgfHxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5hbGxvd1N0YWxlT25GZXRjaEFib3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGl0IGV2ZW50dWFsbHkgcmVzb2x2ZXMsIHVwZGF0ZSB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFsbG93U3RhbGVPbkZldGNoQWJvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHYgPT4gY2IodiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3RhdHVzKVxuICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hEaXNwYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcCA9IG5ldyBQcm9taXNlKHBjYWxsKS50aGVuKGNiLCBlYik7XG4gICAgICAgIGNvbnN0IGJmID0gT2JqZWN0LmFzc2lnbihwLCB7XG4gICAgICAgICAgICBfX2Fib3J0Q29udHJvbGxlcjogYWMsXG4gICAgICAgICAgICBfX3N0YWxlV2hpbGVGZXRjaGluZzogdixcbiAgICAgICAgICAgIF9fcmV0dXJuZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBpbnRlcm5hbCwgZG9uJ3QgZXhwb3NlIHN0YXR1cy5cbiAgICAgICAgICAgIHRoaXMuc2V0KGssIGJmLCB7IC4uLmZldGNoT3B0cy5vcHRpb25zLCBzdGF0dXM6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy4ja2V5TWFwLmdldChrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI3ZhbExpc3RbaW5kZXhdID0gYmY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJmO1xuICAgIH1cbiAgICAjaXNCYWNrZ3JvdW5kRmV0Y2gocCkge1xuICAgICAgICBpZiAoIXRoaXMuI2hhc0ZldGNoTWV0aG9kKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBiID0gcDtcbiAgICAgICAgcmV0dXJuICghIWIgJiZcbiAgICAgICAgICAgIGIgaW5zdGFuY2VvZiBQcm9taXNlICYmXG4gICAgICAgICAgICBiLmhhc093blByb3BlcnR5KCdfX3N0YWxlV2hpbGVGZXRjaGluZycpICYmXG4gICAgICAgICAgICBiLl9fYWJvcnRDb250cm9sbGVyIGluc3RhbmNlb2YgQUMpO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaChrLCBmZXRjaE9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IFxuICAgICAgICAvLyBnZXQgb3B0aW9uc1xuICAgICAgICBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlLCB1cGRhdGVBZ2VPbkdldCA9IHRoaXMudXBkYXRlQWdlT25HZXQsIG5vRGVsZXRlT25TdGFsZUdldCA9IHRoaXMubm9EZWxldGVPblN0YWxlR2V0LCBcbiAgICAgICAgLy8gc2V0IG9wdGlvbnNcbiAgICAgICAgdHRsID0gdGhpcy50dGwsIG5vRGlzcG9zZU9uU2V0ID0gdGhpcy5ub0Rpc3Bvc2VPblNldCwgc2l6ZSA9IDAsIHNpemVDYWxjdWxhdGlvbiA9IHRoaXMuc2l6ZUNhbGN1bGF0aW9uLCBub1VwZGF0ZVRUTCA9IHRoaXMubm9VcGRhdGVUVEwsIFxuICAgICAgICAvLyBmZXRjaCBleGNsdXNpdmUgb3B0aW9uc1xuICAgICAgICBub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24gPSB0aGlzLm5vRGVsZXRlT25GZXRjaFJlamVjdGlvbiwgYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb24gPSB0aGlzLmFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uLCBpZ25vcmVGZXRjaEFib3J0ID0gdGhpcy5pZ25vcmVGZXRjaEFib3J0LCBhbGxvd1N0YWxlT25GZXRjaEFib3J0ID0gdGhpcy5hbGxvd1N0YWxlT25GZXRjaEFib3J0LCBjb250ZXh0LCBmb3JjZVJlZnJlc2ggPSBmYWxzZSwgc3RhdHVzLCBzaWduYWwsIH0gPSBmZXRjaE9wdGlvbnM7XG4gICAgICAgIGlmICghdGhpcy4jaGFzRmV0Y2hNZXRob2QpIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmZldGNoID0gJ2dldCc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoaywge1xuICAgICAgICAgICAgICAgIGFsbG93U3RhbGUsXG4gICAgICAgICAgICAgICAgdXBkYXRlQWdlT25HZXQsXG4gICAgICAgICAgICAgICAgbm9EZWxldGVPblN0YWxlR2V0LFxuICAgICAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhbGxvd1N0YWxlLFxuICAgICAgICAgICAgdXBkYXRlQWdlT25HZXQsXG4gICAgICAgICAgICBub0RlbGV0ZU9uU3RhbGVHZXQsXG4gICAgICAgICAgICB0dGwsXG4gICAgICAgICAgICBub0Rpc3Bvc2VPblNldCxcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICBzaXplQ2FsY3VsYXRpb24sXG4gICAgICAgICAgICBub1VwZGF0ZVRUTCxcbiAgICAgICAgICAgIG5vRGVsZXRlT25GZXRjaFJlamVjdGlvbixcbiAgICAgICAgICAgIGFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uLFxuICAgICAgICAgICAgYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCxcbiAgICAgICAgICAgIGlnbm9yZUZldGNoQWJvcnQsXG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICBzaWduYWwsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuI2tleU1hcC5nZXQoayk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5mZXRjaCA9ICdtaXNzJztcbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLiNiYWNrZ3JvdW5kRmV0Y2goaywgaW5kZXgsIG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIChwLl9fcmV0dXJuZWQgPSBwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluIGNhY2hlLCBtYXliZSBhbHJlYWR5IGZldGNoaW5nXG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgICAgICBpZiAodGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFsZSA9IGFsbG93U3RhbGUgJiYgdi5fX3N0YWxlV2hpbGVGZXRjaGluZyAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmZldGNoID0gJ2luZmxpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnJldHVybmVkU3RhbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhbGUgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nIDogKHYuX19yZXR1cm5lZCA9IHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgd2UgZm9yY2UgYSByZWZyZXNoLCB0aGF0IG1lYW5zIGRvIE5PVCBzZXJ2ZSB0aGUgY2FjaGVkIHZhbHVlLFxuICAgICAgICAgICAgLy8gdW5sZXNzIHdlIGFyZSBhbHJlYWR5IGluIHRoZSBwcm9jZXNzIG9mIHJlZnJlc2hpbmcgdGhlIGNhY2hlLlxuICAgICAgICAgICAgY29uc3QgaXNTdGFsZSA9IHRoaXMuI2lzU3RhbGUoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKCFmb3JjZVJlZnJlc2ggJiYgIWlzU3RhbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZmV0Y2ggPSAnaGl0JztcbiAgICAgICAgICAgICAgICB0aGlzLiNtb3ZlVG9UYWlsKGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlQWdlT25HZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jdXBkYXRlSXRlbUFnZShpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3N0YXR1c1RUTChzdGF0dXMsIGluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9rLCBpdCBpcyBzdGFsZSBvciBhIGZvcmNlZCByZWZyZXNoLCBhbmQgbm90IGFscmVhZHkgZmV0Y2hpbmcuXG4gICAgICAgICAgICAvLyByZWZyZXNoIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLiNiYWNrZ3JvdW5kRmV0Y2goaywgaW5kZXgsIG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3QgaGFzU3RhbGUgPSBwLl9fc3RhbGVXaGlsZUZldGNoaW5nICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBzdGFsZVZhbCA9IGhhc1N0YWxlICYmIGFsbG93U3RhbGU7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmZldGNoID0gaXNTdGFsZSA/ICdzdGFsZScgOiAncmVmcmVzaCc7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWxlVmFsICYmIGlzU3RhbGUpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5yZXR1cm5lZFN0YWxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGFsZVZhbCA/IHAuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiAocC5fX3JldHVybmVkID0gcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgdmFsdWUgZnJvbSB0aGUgY2FjaGUuIFdpbGwgdXBkYXRlIHRoZSByZWNlbmN5IG9mIHRoZSBjYWNoZVxuICAgICAqIGVudHJ5IGZvdW5kLlxuICAgICAqXG4gICAgICogSWYgdGhlIGtleSBpcyBub3QgZm91bmQsIGdldCgpIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIGdldChrLCBnZXRPcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlLCB1cGRhdGVBZ2VPbkdldCA9IHRoaXMudXBkYXRlQWdlT25HZXQsIG5vRGVsZXRlT25TdGFsZUdldCA9IHRoaXMubm9EZWxldGVPblN0YWxlR2V0LCBzdGF0dXMsIH0gPSBnZXRPcHRpb25zO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuI2tleU1hcC5nZXQoayk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZhbExpc3RbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgZmV0Y2hpbmcgPSB0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgIHRoaXMuI3N0YXR1c1RUTChzdGF0dXMsIGluZGV4KTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpc1N0YWxlKGluZGV4KSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5nZXQgPSAnc3RhbGUnO1xuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBvbmx5IGlmIG5vdCBhbiBpbi1mbGlnaHQgYmFja2dyb3VuZCBmZXRjaFxuICAgICAgICAgICAgICAgIGlmICghZmV0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0RlbGV0ZU9uU3RhbGVHZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlKGspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgJiYgYWxsb3dTdGFsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5yZXR1cm5lZFN0YWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsbG93U3RhbGUgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93U3RhbGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl9fc3RhbGVXaGlsZUZldGNoaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5yZXR1cm5lZFN0YWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsb3dTdGFsZSA/IHZhbHVlLl9fc3RhbGVXaGlsZUZldGNoaW5nIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5nZXQgPSAnaGl0JztcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBjdXJyZW50bHkgZmV0Y2hpbmcgaXQsIHdlIGRvbid0IGFjdHVhbGx5IGhhdmUgaXQgeWV0XG4gICAgICAgICAgICAgICAgLy8gaXQncyBub3Qgc3RhbGUsIHdoaWNoIG1lYW5zIHRoaXMgaXNuJ3QgYSBzdGFsZVdoaWxlUmVmZXRjaGluZy5cbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIG5vdCBzdGFsZSwgYW5kIGZldGNoaW5nLCBBTkQgaGFzIGEgX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZSwgdGhlbiB0aGF0IG1lYW5zIHRoZSB1c2VyIGZldGNoZWQgd2l0aCB7Zm9yY2VSZWZyZXNoOnRydWV9LFxuICAgICAgICAgICAgICAgIC8vIHNvIGl0J3Mgc2FmZSB0byByZXR1cm4gdGhhdCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoZmV0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLl9fc3RhbGVXaGlsZUZldGNoaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNtb3ZlVG9UYWlsKGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlQWdlT25HZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jdXBkYXRlSXRlbUFnZShpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgIHN0YXR1cy5nZXQgPSAnbWlzcyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2Nvbm5lY3QocCwgbikge1xuICAgICAgICB0aGlzLiNwcmV2W25dID0gcDtcbiAgICAgICAgdGhpcy4jbmV4dFtwXSA9IG47XG4gICAgfVxuICAgICNtb3ZlVG9UYWlsKGluZGV4KSB7XG4gICAgICAgIC8vIGlmIHRhaWwgYWxyZWFkeSwgbm90aGluZyB0byBkb1xuICAgICAgICAvLyBpZiBoZWFkLCBtb3ZlIGhlYWQgdG8gbmV4dFtpbmRleF1cbiAgICAgICAgLy8gZWxzZVxuICAgICAgICAvLyAgIG1vdmUgbmV4dFtwcmV2W2luZGV4XV0gdG8gbmV4dFtpbmRleF0gKGhlYWQgaGFzIG5vIHByZXYpXG4gICAgICAgIC8vICAgbW92ZSBwcmV2W25leHRbaW5kZXhdXSB0byBwcmV2W2luZGV4XVxuICAgICAgICAvLyBwcmV2W2luZGV4XSA9IHRhaWxcbiAgICAgICAgLy8gbmV4dFt0YWlsXSA9IGluZGV4XG4gICAgICAgIC8vIHRhaWwgPSBpbmRleFxuICAgICAgICBpZiAoaW5kZXggIT09IHRoaXMuI3RhaWwpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy4jaGVhZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2hlYWQgPSB0aGlzLiNuZXh0W2luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QodGhpcy4jcHJldltpbmRleF0sIHRoaXMuI25leHRbaW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QodGhpcy4jdGFpbCwgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy4jdGFpbCA9IGluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSBrZXkgb3V0IG9mIHRoZSBjYWNoZS5cbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGtleSB3YXMgZGVsZXRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGRlbGV0ZShrKSB7XG4gICAgICAgIGxldCBkZWxldGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLiNzaXplICE9PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuI2tleU1hcC5nZXQoayk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNzaXplID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3JlbW92ZUl0ZW1TaXplKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQobmV3IEVycm9yKCdkZWxldGVkJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuI2hhc0Rpc3Bvc2UgfHwgdGhpcy4jaGFzRGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2U/Lih2LCBrLCAnZGVsZXRlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZWQ/LnB1c2goW3YsIGssICdkZWxldGUnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4ja2V5TWFwLmRlbGV0ZShrKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4ja2V5TGlzdFtpbmRleF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3ZhbExpc3RbaW5kZXhdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMuI3RhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI3RhaWwgPSB0aGlzLiNwcmV2W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gdGhpcy4jaGVhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jaGVhZCA9IHRoaXMuI25leHRbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV4dFt0aGlzLiNwcmV2W2luZGV4XV0gPSB0aGlzLiNuZXh0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI3ByZXZbdGhpcy4jbmV4dFtpbmRleF1dID0gdGhpcy4jcHJldltpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jc2l6ZS0tO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNmcmVlLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZUFmdGVyICYmIHRoaXMuI2Rpc3Bvc2VkPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGR0ID0gdGhpcy4jZGlzcG9zZWQ7XG4gICAgICAgICAgICBsZXQgdGFzaztcbiAgICAgICAgICAgIHdoaWxlICgodGFzayA9IGR0Py5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VBZnRlcj8uKC4uLnRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWxldGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgY2FjaGUgZW50aXJlbHksIHRocm93aW5nIGF3YXkgYWxsIHZhbHVlcy5cbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiB0aGlzLiNyaW5kZXhlcyh7IGFsbG93U3RhbGU6IHRydWUgfSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICAgICAgICAgIHYuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQobmV3IEVycm9yKCdkZWxldGVkJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgayA9IHRoaXMuI2tleUxpc3RbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2U/Lih2LCBrLCAnZGVsZXRlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZWQ/LnB1c2goW3YsIGssICdkZWxldGUnXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2tleU1hcC5jbGVhcigpO1xuICAgICAgICB0aGlzLiN2YWxMaXN0LmZpbGwodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy4ja2V5TGlzdC5maWxsKHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICh0aGlzLiN0dGxzICYmIHRoaXMuI3N0YXJ0cykge1xuICAgICAgICAgICAgdGhpcy4jdHRscy5maWxsKDApO1xuICAgICAgICAgICAgdGhpcy4jc3RhcnRzLmZpbGwoMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI3NpemVzKSB7XG4gICAgICAgICAgICB0aGlzLiNzaXplcy5maWxsKDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2hlYWQgPSAwO1xuICAgICAgICB0aGlzLiN0YWlsID0gMDtcbiAgICAgICAgdGhpcy4jZnJlZS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLiNjYWxjdWxhdGVkU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuI3NpemUgPSAwO1xuICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZUFmdGVyICYmIHRoaXMuI2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBkdCA9IHRoaXMuI2Rpc3Bvc2VkO1xuICAgICAgICAgICAgbGV0IHRhc2s7XG4gICAgICAgICAgICB3aGlsZSAoKHRhc2sgPSBkdD8uc2hpZnQoKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlQWZ0ZXI/LiguLi50YXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTFJVQ2FjaGUgPSBMUlVDYWNoZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkxSVUNhY2hlIiwicGVyZiIsInBlcmZvcm1hbmNlIiwibm93IiwiRGF0ZSIsIndhcm5lZCIsIlNldCIsIlBST0NFU1MiLCJwcm9jZXNzIiwiZW1pdFdhcm5pbmciLCJtc2ciLCJ0eXBlIiwiY29kZSIsImZuIiwiY29uc29sZSIsImVycm9yIiwiQUMiLCJnbG9iYWxUaGlzIiwiQWJvcnRDb250cm9sbGVyIiwiQVMiLCJBYm9ydFNpZ25hbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJfIiwiX29uYWJvcnQiLCJwdXNoIiwiYWJvcnRlZCIsImNvbnN0cnVjdG9yIiwic2lnbmFsIiwid2FybkFDUG9seWZpbGwiLCJhYm9ydCIsInJlYXNvbiIsIm9uYWJvcnQiLCJwcmludEFDUG9seWZpbGxXYXJuaW5nIiwiZW52IiwiTFJVX0NBQ0hFX0lHTk9SRV9BQ19XQVJOSU5HIiwic2hvdWxkV2FybiIsImhhcyIsIlRZUEUiLCJTeW1ib2wiLCJpc1Bvc0ludCIsIm4iLCJNYXRoIiwiZmxvb3IiLCJpc0Zpbml0ZSIsImdldFVpbnRBcnJheSIsIm1heCIsInBvdyIsIlVpbnQ4QXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsIlplcm9BcnJheSIsIkFycmF5Iiwic2l6ZSIsImZpbGwiLCJTdGFjayIsImNvbnN0cnVjdGluZyIsImNyZWF0ZSIsIkhlYXBDbHMiLCJzIiwiVHlwZUVycm9yIiwiaGVhcCIsImxlbmd0aCIsInBvcCIsIm1heFNpemUiLCJkaXNwb3NlIiwiZGlzcG9zZUFmdGVyIiwiZmV0Y2hNZXRob2QiLCJjYWxjdWxhdGVkU2l6ZSIsImtleU1hcCIsImtleUxpc3QiLCJ2YWxMaXN0IiwibmV4dCIsInByZXYiLCJoZWFkIiwidGFpbCIsImZyZWUiLCJkaXNwb3NlZCIsInNpemVzIiwic3RhcnRzIiwidHRscyIsImhhc0Rpc3Bvc2UiLCJoYXNGZXRjaE1ldGhvZCIsImhhc0Rpc3Bvc2VBZnRlciIsInVuc2FmZUV4cG9zZUludGVybmFscyIsImMiLCJpc0JhY2tncm91bmRGZXRjaCIsInAiLCJiYWNrZ3JvdW5kRmV0Y2giLCJrIiwiaW5kZXgiLCJvcHRpb25zIiwiY29udGV4dCIsIm1vdmVUb1RhaWwiLCJpbmRleGVzIiwicmluZGV4ZXMiLCJpc1N0YWxlIiwidXBkYXRlSXRlbUFnZSIsInN0YXR1c1RUTCIsInNldEl0ZW1UVEwiLCJyZW1vdmVJdGVtU2l6ZSIsIl9pIiwiYWRkSXRlbVNpemUiLCJfcyIsIl9zdCIsInJlcXVpcmVTaXplIiwiX2siLCJfdiIsInNpemVDYWxjdWxhdGlvbiIsInR0bCIsInR0bFJlc29sdXRpb24iLCJ0dGxBdXRvcHVyZ2UiLCJ1cGRhdGVBZ2VPbkdldCIsInVwZGF0ZUFnZU9uSGFzIiwiYWxsb3dTdGFsZSIsIm5vRGlzcG9zZU9uU2V0Iiwibm9VcGRhdGVUVEwiLCJtYXhFbnRyeVNpemUiLCJub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24iLCJub0RlbGV0ZU9uU3RhbGVHZXQiLCJhbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbiIsImFsbG93U3RhbGVPbkZldGNoQWJvcnQiLCJpZ25vcmVGZXRjaEFib3J0IiwiVWludEFycmF5IiwiRXJyb3IiLCJ1bmRlZmluZWQiLCJNYXAiLCJpbml0aWFsaXplU2l6ZVRyYWNraW5nIiwiaW5pdGlhbGl6ZVRUTFRyYWNraW5nIiwiYWRkIiwiZ2V0UmVtYWluaW5nVFRMIiwia2V5IiwiSW5maW5pdHkiLCJzdGFydCIsInQiLCJzZXRUaW1lb3V0IiwiZGVsZXRlIiwidW5yZWYiLCJzdGF0dXMiLCJjYWNoZWROb3ciLCJnZXROb3ciLCJhZ2UiLCJyZW1haW5pbmdUVEwiLCJnZXQiLCJ2IiwiZXZpY3QiLCJlbnRyeVNpemUiLCJ0b3RhbENhbGN1bGF0ZWRTaXplIiwiaSIsImlzVmFsaWRJbmRleCIsImVudHJpZXMiLCJyZW50cmllcyIsImtleXMiLCJya2V5cyIsInZhbHVlcyIsInJ2YWx1ZXMiLCJpdGVyYXRvciIsImZpbmQiLCJnZXRPcHRpb25zIiwiX19zdGFsZVdoaWxlRmV0Y2hpbmciLCJmb3JFYWNoIiwidGhpc3AiLCJjYWxsIiwicmZvckVhY2giLCJwdXJnZVN0YWxlIiwiZGVsZXRlZCIsImR1bXAiLCJhcnIiLCJlbnRyeSIsInVuc2hpZnQiLCJsb2FkIiwiY2xlYXIiLCJzZXQiLCJzZXRPcHRpb25zIiwibWF4RW50cnlTaXplRXhjZWVkZWQiLCJvbGRWYWwiLCJfX2Fib3J0Q29udHJvbGxlciIsIm9sZFZhbHVlIiwiZHQiLCJ0YXNrIiwic2hpZnQiLCJ2YWwiLCJoYXNPcHRpb25zIiwicGVlayIsInBlZWtPcHRpb25zIiwiYWMiLCJmZXRjaE9wdHMiLCJjYiIsInVwZGF0ZUNhY2hlIiwiaWdub3JlQWJvcnQiLCJmZXRjaEFib3J0ZWQiLCJmZXRjaEVycm9yIiwiZmV0Y2hBYm9ydElnbm9yZWQiLCJmZXRjaFJlc29sdmVkIiwiZmV0Y2hGYWlsIiwiYmYiLCJmZXRjaFVwZGF0ZWQiLCJlYiIsImVyIiwiZmV0Y2hSZWplY3RlZCIsImFsbG93U3RhbGVBYm9ydGVkIiwibm9EZWxldGUiLCJkZWwiLCJyZXR1cm5lZFN0YWxlIiwiX19yZXR1cm5lZCIsInBjYWxsIiwicmVzIiwicmVqIiwiZm1wIiwiUHJvbWlzZSIsInRoZW4iLCJmZXRjaERpc3BhdGNoZWQiLCJhc3NpZ24iLCJiIiwiaGFzT3duUHJvcGVydHkiLCJmZXRjaCIsImZldGNoT3B0aW9ucyIsImZvcmNlUmVmcmVzaCIsInN0YWxlIiwiaGFzU3RhbGUiLCJzdGFsZVZhbCIsImZldGNoaW5nIiwiY29ubmVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/lru-cache/dist/cjs/index.js\n");

/***/ })

};
;